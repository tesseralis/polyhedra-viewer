{"version":3,"sources":["styles/common.ts","math/geom.ts","math/polyhedra/index.ts","math/polyhedra/FaceLike.ts","math/polyhedra/Facet.ts","math/polyhedra/Edge.ts","math/polyhedra/Vertex.ts","math/polyhedra/Polyhedron.ts","math/polyhedra/Face.ts","math/polyhedra/Cap.ts","math/polyhedra/SolidBuilder.ts","images/sad-scutoid.png","components/ViewerPage/conway.ts","components/ErrorPage.tsx","math/formes/PolyhedronForme.ts","math/operations/operationUtils.ts","math/formes/ClassicalForme.ts","math/formes/CapstoneForme.ts","math/formes/CompositeForme.ts","math/formes/createForme.ts","components/ViewerPage/context/PolyhedronCtx.tsx","components/ViewerPage/context/OperationCtx.tsx","components/ViewerPage/context/TransitionCtx.tsx","transition.ts","components/ViewerPage/context/useApplyOperation.tsx","math/operations/operationPairs.ts","math/operations/Operation.ts","math/operations/truncateOps/truncateHelpers.ts","math/operations/truncateOps/truncateRegular.ts","math/operations/truncateOps/truncateAmbo.ts","math/operations/truncateOps/truncateAugmented.ts","math/operations/truncateOps/index.ts","math/operations/resizeOps.ts","math/operations/prismOps.ts","math/operations/cutPasteOps/addCap.ts","math/operations/cutPasteOps/cutPasteUtils.ts","math/operations/cutPasteOps/removeCap.ts","math/operations/cutPasteOps/cutPasteCapstone.ts","math/operations/cutPasteOps/cutPasteAugmented.ts","math/operations/cutPasteOps/cutPasteDiminished.ts","math/operations/cutPasteOps/cutPasteGyrate.ts","math/operations/cutPasteOps/cutPasteElementary.ts","math/operations/cutPasteOps/gyrate.ts","math/operations/cutPasteOps/index.ts","math/operations/index.ts","components/svg.tsx","components/ViewerPage/common/OperationIcon.tsx","components/ViewerPage/common/OpGrid.tsx","components/ViewerPage/common/ResizeButtons.tsx","components/ViewerPage/common/Options/TwistOptions.tsx","components/ViewerPage/common/Options/OptionIcon.tsx","components/ViewerPage/common/Options/AugmentOptions.tsx","components/ViewerPage/common/Options/Options.tsx","components/ViewerPage/common/SolidScene/ThreePolyhedron.tsx","components/ViewerPage/common/SolidScene/useSolidContext.tsx","components/ViewerPage/common/SolidScene/ThreeScene.tsx","components/ViewerPage/common/SolidScene/index.tsx","components/ViewerPage/common/SolidScene/useHitOptions.tsx","components/ViewerPage/common/IconLink.tsx","components/ViewerPage/common/BackLink.tsx","components/ViewerPage/common/NavMenu.tsx","components/ViewerPage/common/DataDownloader.tsx","components/ViewerPage/common/InfoPanel/renderFuncs.tsx","components/ViewerPage/common/InfoPanel/DataList.tsx","components/ViewerPage/common/InfoPanel/InfoPanel.tsx","components/ViewerPage/common/ConfigForm.tsx","data/list.ts","components/ViewerPage/common/ListPanel/SearchBar.tsx","components/ViewerPage/common/ListPanel/ListPanel.tsx","components/ViewerPage/common/Panels.tsx","components/ViewerPage/common/Title.tsx","components/ViewerPage/common/ImageDownloader.tsx","components/ViewerPage/common/Prompt.tsx","components/ViewerPage/common/useHiddenHeading.tsx","components/ViewerPage/DesktopViewer/OperationsPanel.tsx","components/ViewerPage/DesktopViewer/Sidebar.tsx","components/ViewerPage/DesktopViewer/Overlay.tsx","components/ViewerPage/DesktopViewer/DesktopViewer.tsx","components/ViewerPage/MobileViewer/OperationsPanel.tsx","components/ViewerPage/MobileViewer/MobileViewer.tsx","components/ViewerPage/Viewer.tsx","components/ViewerPage/ViewerPage.tsx"],"names":["marginVert","m","marginTop","marginBottom","marginHoriz","marginLeft","marginRight","margin","vert","horiz","paddingVert","p","paddingTop","paddingBottom","paddingHoriz","paddingLeft","paddingRight","padding","square","size","width","height","flexRow","alignItems","justifyContent","display","flexDirection","flexColumn","absolute","position","absoluteFull","top","left","right","bottom","scroll","direction","toUpperCase","colorFill","color","fill","hover","backgroundColor","link","textDecoration","PRECISION","vecEquals","v1","v2","distanceToSquared","getMidpoint","Vector3","addVectors","divideScalar","isInverse","clone","negate","angleBetween","o","a","b","sub","angleTo","isPlanar","points","plane","length","Error","Plane","setFromCoplanarPoints","getPlane","every","vec","Math","abs","distanceToPoint","getCentroid","vectors","reduce","add","getNormal","vertices","v0","cross","normalize","translateMat","v","Matrix4","makeTranslation","x","y","z","scaleMat","s","makeScale","withOrigin","mat","getInverse","premultiply","PI","sin","tan","FaceLike","edges","polyhedron","map","this","edge","twin","face","filter","e","isValid","setFromNormalAndCoplanarPoint","normal","centroid","sideLength","numSides","apothem","Facet","once","Ray","distanceTo","angle","makeRotationAxis","amount","scaled","setLength","Edge","find","equals","index","midpoint","twinFace","edgeToFaceGraph","getCycles","array","val","i","splitAt","front","back","arrayMin","a1","a2","h1","t1","h2","t2","Vertex","_solidData","other","some","vertex","parseInt","findKey","e0","count","prev","adjacentEdgesIter","adjacentEdges","config","adjacentFaces","f","concat","reverse","countBy","cbrt","Polyhedron","solidData","faces","_edges","edgesToFaces","set","caps","Cap","getAll","vIndex","fIndex","Face","toArray","numVertices","numEdges","numFaces","maxBy","minBy","n","sortBy","Object","keys","numFacesBySides","configuration","join","getFace","sum","area","surfaceArea","edgeLength","distanceToCenter","volume","point","changes","Builder","build","withChanges","withVertices","withFaces","withoutFaces","addPolyhedron","mapVertices","mapFaces","scale","multiplyScalar","facesBySides","faceAdjacencyCounts","adj","adjacentFaceCounts","polygons","isEqual","faceAdjacencyList","flatMap","value","data","name","fromRawData","getSolidData","getCyclic","flatMapUniq","createMapper","mapper","Base","arg","cap","innerVertices","type","topPoint","faceConfiguration","_innerVertices","allVertices","boundary","inSet","result","next","push","nextTwin","getBoundary","hitPoint","hitFace","pyramids","Pyramid","fastigium","Fastigium","cupolaRotunda","Cupola","Rotunda","faceCount","adjacentVertices","normalizeVertex","normalizeFace","Array","isArray","iteratee","removed","pullAt","addVertices","addFaces","module","exports","getConwayNotation","getCanonicalSpecs","conwaySymbol","conwayMapping","BiMap","allSolidNames","Image","css","useStyle","scales","src","image","alt","Title","textAlign","fontFamily","fonts","andaleMono","fontSize","font","media","mobile","BackLink","to","ErrorPage","usePageTitle","gridGap","spacing","alignContent","justifyItems","PolyhedronForme","specs","geom","oppositeFace","twist","getTransform","origin","u1","u2","_u1","projectOnPlane","normalizeOrientation","orientation","translateM","scaleM","makeBasis","alignPolyhedron","solid","oldPose","newPose","oldMat","newMat","oldMatInv","newVertices","applyMatrix4","getGeometry","get","canonicalName","isClassical","isSnub","reflect","isCapstone","isChiral","isCupolaRotunda","removeExtraneousVertices","vertsInFaces","toRemove","numToRemove","notToRemove","takeRight","newToOld","mapObject","oldToNew","invert","dropRight","deduplicateVertices","unique","forEach","match","undefined","isEmpty","newFaces","uniq","vIndices","normalizeTransform","t","getTransformedVertices","vLists","vList","ClassicalForme","facet","family","faceType","isTetrahedral","tetrahedralFacetFaces","_isFacetFace","facets","isFacetFace","f0","facetFace","adjacentFacetFace","oppositeFacet","mainFacet","minorFacet","facetFaces","isAnyFacetFace","isEdgeFace","getVertex","operation","RegularForme","TruncatedForme","RectifiedForme","BevelledForme","CantellatedForme","SnubForme","create","getSpecs","fromSpecs","getEdge","faceWithNumSides","rest","oppositeTwist","adjacentFacetFaces","face0","face1","projectPoint","CapstoneForme","bases","base","baseBoundaries","bot","baseOf","SnubCapstoneForme","PrismaticForme","MonoCapstoneForme","BiCapstoneForme","isDigonal","edge1","edge2","baseSides","face2","isPrimary","cap2","CompositeForme","capInnerVertIndices","Set","isAugmentedClassical","isAugmentedPrism","isDiminishedSolid","isGyrateSolid","has","sourceVertices","isMono","hasAlignment","getSingle","modifications","AugmentedPrismForme","AugmentedClassicalForme","DiminishedSolidForme","GyrateSolidForme","isComposite","baseFaces","sourcePrism","isTriangular","isSquare","isSecondary","isSideFace","sourceClassical","isIcosahedral","isRegular","isSourceFace","isMainFace","isMinorFace","isCapTop","isDiminished","largestFace","isAugmented","isDiminishedFace","augmentedCaps","diminishedFaces","isGyrate","gyrateCaps","createForme","defaultProps","createHookedContext","setPolyhedron","forme","setPolyhedronToName","current","defaultState","options","setOperation","defaultOptions","unsetOperation","setOption","getFaceColors","mapping","colors","Color","faceColors","isTransitioning","InterpModel","reset","TransitionContext","React","createContext","noop","InnerProvider","children","transitionId","useRef","PolyhedronCtx","useActions","Config","useState","animationSpeed","enableAnimation","anim","useEffect","cancel","transitionFn","useCallback","animationData","start","endVertices","startColors","endColors","startFaceColors","endFaceColors","updateCallback","duration","ease","onFinish","id","requestAnimationFrame","step","timestamp","delta","progress","min","d3","cancelAnimationFrame","transition","lerpVectors","lerp","lerpColors","Provider","useTransition","useContext","useApplyOperation","OperationCtx","TransitionCtx","callback","apply","hasOptions","canApplyTo","oppositeSide","side","toDirected","graph","entry","end","defaultGetter","OpPair","inputs","opts","isMatch","findEntry","JSON","stringify","getEntries","getEntry","middle","getMiddle","getPose","toLeft","toRight","solidForme","startPose","endSide","endSpecs","endGeom","alignedEnd","inter","middleSolid","PolyhedronSpecs","alignedInter","startFn","endFn","makeOperation","op","toGraphOpts","makeOpPair","opInput","combineOps","opArgs","getOp","pickBy","methodDefaults","getHitOption","pairs","found","f1","f2","getCoplanarFaces","numUniqueSides","arrayDefaults","first","second","item","Operation","hitOption","mapValues","fnDefault","fn","getResult","opResult","newSpecs","normedResult","normalizeOpResult","hitPnt","optionName","allOptions","compact","cartesian","selectionState","getSharpenPoint","p1","p2","ray","normalRay","theta1","dist","at","getSharpenPointEdge","makeTruncateTrio","args","makePair","leftOp","rightOp","middleArg","Classical","allWithOperation","withOperation","$","transformer","truncate","cotruncate","rectify","getRegularPose","minorFacetFaces","isMainFacetFace","avgInradius","inradius","refForme","refInradius","circumradius","edgeFaces","addScaledVector","edgeFace","refMidradius","translateNormal","withCentroidOrigin","radius","multiply","Composite","query","where","source","withData","crossAxis","sourceCentroid","isTri","isBi","isMeta","mainFace","truncatedFaces","minorFaces","cupolaFaces","capTops","otherFace","regs","ambos","augTruncate","hitOptArgs","getFacet","sharpen","getClassicalPose","getResizeArgs","pos","resultForme","snubAngle","distance","rotateM","rotateNormal","getResizedVertices","resizeArgs","semiExpand","_expand","_snub","twists","isVertex","_twist","getCantellatedMidradius","doDualTransform","midradius","_dual","_","dual","expand","snub","contract","getTwistMult","getCapstonePose","isPrismatic","isGyroelongated","applyAxisAngle","doPrismTransform","prismaticHeight","vertexSets","getScaledPrismVertices","makePrismOp","rightElongation","leftElongation","Capstone","elongation","withElongation","turnPrismatic","isPrism","_elongate","canGyroelongSecondary","pyramidOps","canGyroelongPrimary","gyroelongPyramid","turnPyramid","cupolaOps","gyroelongCupola","turnCupola","makeBicupolaPrismOp","isGyro","gyroelongBicupola","turnBicupola","elongate","gyroelongate","shorten","turn","defaultCrossAxis","defaultCapType","getCap","isShortened","capType","capOrientation","canAugment","getUsingOpts","info","isPentagonal","hasRotunda","hasGyrateOpts","defaultGraphOpts","makeCutPastePair","input","augment","toAugGraphOpts","using","baseAxis","baseCrossAxis","includes","capPose","basePose","alignedAugmentee","capInitial","repeat","endResult","addCap","diminish","toDimGraphOpts","mockPolyhedron","range","removeCap","getCaps","baseCaps","capOptionArgs","allCapFaces","augOptionArgs","gyrate","gyrations","usingOpts","capTypes","remove","orientationFn","isAugmentedSolid","align","alignment","isTruncated","augmentDiminished","augmentGyrate","Elementary","withName","TAU","makeGyrateOp","theta","applyGyrate","gyrateCapstone","hasGyrate","isOrtho","gyrateComposite","ungyrate","ops","capstone","augmented","diminished","gyrated","elementary","operations","cos","joinPoints","PolyShape","PolyLine","polygonPoints","r","cx","cy","Polygon","sqrt","styles","inputStyles","StyleSheet","key","makeStyles","operationIcon","invariant","stroke","strokeWidth","strokeLinejoin","subtracted","strokeDasharray","added","changed","TruncateIcon","styled","innerSides","innerScale","innerAngle","center","className","DualIcon","BaseExpandIcon","render","Renderer","hollow","ap","r1","ap1","ExpandIcon","innerStyle","transform","ElongateIcon","AugmentIcon","memo","viewBox","drawIcon","opLayout","opList","flat","OpButton","disabled","currentOp","applyOperation","isCurrent","border","verdana","opacity","style","gridArea","onClick","templateString","line","OpGrid","notMobile","gridColumnGap","gridRowGap","gridTemplateAreas","ResetButton","props","alignSelf","buttons","handler","normalizeToVolume","ResizeButtons","gridTemplateColumns","columnGap","TwistOption","handleClick","pointerEvents","background","path","mdiRotateLeft","mdiRotateRight","rotate","TwistOptions","InnerIcon","inner","outer","take","p3","p4","p5","p6","bottomY","q1","q2","OptionButton","optValue","selected","htmlProps","AugmentOptions","optionCss","Options","opName","convertFaces","zip","vs","slice","Face3","convertFace","ThreePolyhedron","onPointerMove","onPointerOut","hasMoved","showFaces","showEdges","showInnerFaces","ref","useUpdate","verticesNeedUpdate","elementsNeedUpdate","colorsNeedUpdate","computeFaceNormals","edgeGeom","useMemo","BufferGeometry","positions","Float32Array","setAttribute","BufferAttribute","useFrame","attributes","i1","i2","j","setDrawRange","needsUpdate","onPointerDown","onPointerUp","attach","DoubleSide","FrontSide","vertexColors","transparent","geometry","linewidth","toColor","lighten","offsetHSL","createFamilyColor","faceColor","vertexColor","primary","secondary","ortho","gyro","colorScheme","2","3","4","5","getCompositeColor","sourceSpecs","scheme","isBaseFace","isAugmentedFace","getFormeColor","getClassicalColor","isBaseTop","inBase","isElongated","getCapstoneColor","CameraControls","useThree","setDefaultCamera","domElement","gl","camera","controls","updateMatrixWorld","update","enabled","noPan","rotateSpeed","staticMoving","extend","TrackballControls","ThreeScene","enableFormeColors","getSelectionColor","formeColors","transitionColors","operationColors","useSolidContext","setHitOption","newHitOptions","newValue","unsetHitOption","applyWithHitOption","useHitOptions","ConfigCtx","antialias","pick","LinkText","text","hidden","mobileLandscape","IconLink","iconName","title","replace","iconOnly","activeCss","mdiChevronLeft","escape","links","icon","mdiFormatListBulleted","mdiInformationOutline","mdiCog","mdiMathCompass","mdiCubeOutline","NavMenu","capitalize","formatDecimal","number","Number","isInteger","vToObj","fToObj","fileFormats","ext","serializer","vObj","fObj","DownloadLink","filename","blob","Blob","url","window","URL","createObjectURL","download","href","mdiDownload","DataDownloader","heading","times","format","groupedVertexConfig","Sub","verticalAlign","Sup","split","properties","check","isDeltahedron","isHoneycomb","infoRows","vConfig","vertexConfiguration","configKeys","typeCount","getShortVertexConfig","faceCounts","polygonNames","round","normalizedVolume","normalizedSurfaceArea","sphericity","symmetry","symbol","symName","order","filteredProps","property","prop","alts","alternateNames","Datum","nameCss","valueCss","DataList","rowProps","Heading","lineHeight","InfoPanel","borderSpacing","borderCollapse","typeCss","downloaderCss","group","rawSolidData","ConfigInput","setValue","inputProps","checked","getInputProps","onChange","el","getInputValue","target","option","LabelledInput","ConfigForm","configInputs","johnsonSubgroups","getEndIndex","groups","polyhedra","getPolyhedraNames","SearchIcon","focused","mdiMagnify","SearchInput","borderRadius","outline","borderColor","placeholder","aria-label","isFocused","setFocus","onFocus","onBlur","getFilteredPolyhedra","toLowerCase","filterSubgroups","subgroups","filterText","PolyhedronLink","overflow","textOverflow","whiteSpace","fontWeight","SubList","SubgroupHeader","Subgroup","GroupHeader","Group","ListPanel","setFilterText","filteredGroups","filterGroups","Panels","panel","OperationsPanel","operationsPanel","tabletPortrait","data-testid","Prompt","message","getMessage","useHiddenHeading","focusFn","focus","tabIndex","buttonCss","menuH","Sidebar","header","focusOnHeader","gridTemplateRows","borderLeft","navCss","borderBottom","contentCss","Overlay","homeLink","prompt","Scene","full","SolidScene","StyledSidebar","minWidth","maxWidth","resizeButtons","opGrid","mobilePortrait","Header","Content","zIndex","navH","sceneCss","borderTop","InnerViewer","navigate","useNavigate","solidSync","setSolidSync","ViewerComponent","useMediaInfo","device","DesktopViewer","MobileViewer","Providers","wrapProviders","Viewer","useParams","resolveSolidName","choose","hasValue","of","fromConwayNotation","isAlternateName","isValidSolid","ViewerPage","params","pathname","useLocation","solidParam","element"],"mappings":"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","file":"static/js/6.54d017c3.chunk.js","sourcesContent":["import { CSSProperties } from \"aphrodite\"\n\ntype Value = string | number\n\n/* Spacing utilities */\n\nexport function marginVert(m: Value): CSSProperties {\n  return {\n    marginTop: m,\n    marginBottom: m,\n  }\n}\n\nexport function marginHoriz(m: Value): CSSProperties {\n  return {\n    marginLeft: m,\n    marginRight: m,\n  }\n}\n\nexport function margin(vert: Value, horiz: Value = vert): CSSProperties {\n  return {\n    ...marginVert(vert),\n    ...marginHoriz(horiz),\n  }\n}\n\nexport function paddingVert(p: Value): CSSProperties {\n  return {\n    paddingTop: p,\n    paddingBottom: p,\n  }\n}\n\nexport function paddingHoriz(p: Value): CSSProperties {\n  return {\n    paddingLeft: p,\n    paddingRight: p,\n  }\n}\n\nexport function padding(vert: Value, horiz: Value = vert): CSSProperties {\n  return {\n    ...paddingHoriz(horiz),\n    ...paddingVert(vert),\n  }\n}\n\n/* Layout utlities */\n\nexport function square(size: Value): CSSProperties {\n  return {\n    width: size,\n    height: size,\n  }\n}\n\n/* Display utilities */\n\nexport function flexRow(\n  alignItems?: CSSProperties[\"alignItems\"],\n  justifyContent?: CSSProperties[\"justifyContent\"],\n): CSSProperties {\n  return {\n    display: \"flex\",\n    flexDirection: \"row\",\n    alignItems,\n    justifyContent,\n  }\n}\n\nexport function flexColumn(\n  alignItems?: CSSProperties[\"alignItems\"],\n  justifyContent?: CSSProperties[\"justifyContent\"],\n): CSSProperties {\n  return {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems,\n    justifyContent,\n  }\n}\n\n/* Position utilities */\n\nexport const fullScreen = {\n  position: \"absolute\",\n  height: \"100%\",\n  width: \"100%\",\n}\n\nexport function absolute(\n  vert: \"top\" | \"bottom\",\n  horiz: \"left\" | \"right\",\n): CSSProperties {\n  return {\n    position: \"absolute\",\n    [vert]: 0,\n    [horiz]: 0,\n  }\n}\n\nexport const absoluteFull: CSSProperties = {\n  position: \"absolute\",\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n}\n\n/* Mobile */\n\nexport function scroll(direction?: \"x\" | \"y\") {\n  const prop = `overflow${(direction ?? \"\").toUpperCase()}`\n  return {\n    [prop]: \"scroll\",\n    // use momentum scrolling on mobile browsers\n    \"-webkit-overflow-scrolling\": \"touch\",\n  }\n}\n\n/* Miscellaneous */\n\n/**\n * Populate the `color` and `fill` properties (useful for icons).\n * @param color the color to fill in\n */\nexport function colorFill(color: string): CSSProperties {\n  return {\n    color,\n    fill: color,\n  }\n}\n\n/* Themeing */\n// TODO  move to new file\n\nexport const hover = {\n  \":hover:not(:disabled)\": {\n    backgroundColor: \"LightGray\",\n  },\n}\n\nexport const link = {\n  ...colorFill(\"MediumBlue\"),\n  textDecoration: \"none\",\n  \":hover\": {\n    textDecoration: \"underline\",\n  },\n}\n","import { Matrix4, Vector3, Plane, Ray } from \"three\"\n\nexport const PRECISION_DIGITS = 3\nexport const PRECISION = 10 ** -PRECISION_DIGITS\n\nexport function vecEquals(v1: Vector3, v2: Vector3) {\n  return v1.distanceToSquared(v2) < PRECISION\n}\n\nexport const getMidpoint = (v1: Vector3, v2: Vector3) =>\n  new Vector3().addVectors(v1, v2).divideScalar(2)\n\nexport function isInverse(v1: Vector3, v2: Vector3) {\n  return vecEquals(v1.clone().negate(), v2)\n}\n\nexport function angleBetween(o: Vector3, a: Vector3, b: Vector3) {\n  // colinear points return NaN, so return 0 instead\n  // FIXME? make sure we don't need to normalize this?\n  return a.clone().sub(o).angleTo(b.clone().sub(o))\n}\n\n// Get the plane containing the given points\nexport function getPlane(points: Vector3[]) {\n  if (points.length < 3) {\n    throw new Error(\"Need at least three points for a plane\")\n  }\n  return new Plane().setFromCoplanarPoints(points[0], points[1], points[2])\n}\n\n// Return whether the set of points lie on a plane\nexport function isPlanar(points: Vector3[]) {\n  const plane = getPlane(points)\n  return points.every((vec) => Math.abs(plane.distanceToPoint(vec)) < PRECISION)\n}\n\nexport function getCentroid(vectors: Vector3[]) {\n  return vectors\n    .reduce((v1, v2) => v1.add(v2), new Vector3())\n    .divideScalar(vectors.length)\n}\n\n// Get the normal of a polygon given its ordered vertices\nexport function getNormal(vertices: Vector3[]) {\n  const [v0, v1, v2] = vertices\n  return v0.clone().sub(v1).cross(v1.clone().sub(v2)).normalize()\n}\n\nexport function getNormalRay(vertices: Vector3[]) {\n  return new Ray(getCentroid(vertices), getNormal(vertices))\n}\n\nexport type Transform = (v: Vector3) => Vector3\n\nexport function translateMat(v: Vector3) {\n  return new Matrix4().makeTranslation(v.x, v.y, v.z)\n}\n\nexport function scaleMat(s: number) {\n  return new Matrix4().makeScale(s, s, s)\n}\n\nexport function withOrigin(o: Vector3, m: Matrix4): Matrix4 {\n  const mat = translateMat(o)\n  const matInv = new Matrix4().getInverse(mat)\n  return matInv.premultiply(m).premultiply(mat)\n}\n","export type { VertexArg } from \"./SolidBuilder\"\nexport type { VertexList } from \"./Vertex\"\nexport { default as Polyhedron } from \"./Polyhedron\"\nexport { default as Vertex } from \"./Vertex\"\nexport { default as FaceLike } from \"./FaceLike\"\nexport { default as Face } from \"./Face\"\nexport { default as Edge } from \"./Edge\"\nexport { default as Cap } from \"./Cap\"\n\nexport * from \"./solidTypes\"\n\nexport { normalizeVertex } from \"./SolidBuilder\"\n","import { Plane, Vector3 } from \"three\"\n\nimport { isPlanar, getNormal } from \"math/geom\"\nimport Facet from \"./Facet\"\nimport type Edge from \"./Edge\"\nimport type Vertex from \"./Vertex\"\n\nconst { PI, sin, tan } = Math\n\n/**\n * An abstract polyhedral Face. An entity of a polyhedron that can be treated as a Face:\n * something containing vertices, edges and lying on a plane.\n * Examples include the boundary of a cupola and a concrete Face.\n */\nexport default class FaceLike extends Facet {\n  // polyhedron: Polyhedron\n  vertices: Vertex[]\n  edges: Edge[]\n  vectors: Vector3[]\n\n  constructor(vertices: Vertex[], edges: Edge[]) {\n    super(vertices[0].polyhedron)\n    this.vertices = vertices\n    this.edges = edges\n    this.vectors = this.vertices.map((v) => v.vec)\n  }\n\n  get numSides() {\n    return this.vertices.length\n  }\n\n  adjacentFaces() {\n    return this.edges.map((edge) => edge.twin().face)\n  }\n\n  numUniqueSides() {\n    return this.edges.filter((e) => e.isValid()).length\n  }\n\n  sideLength() {\n    return this.edges[0].length()\n  }\n\n  isPlanar() {\n    return isPlanar(this.vectors)\n  }\n\n  plane(): Plane {\n    return new Plane().setFromNormalAndCoplanarPoint(\n      this.normal(),\n      this.centroid(),\n    )\n  }\n\n  apothem() {\n    return this.sideLength() / (2 * tan(PI / this.numSides))\n  }\n\n  radius() {\n    return this.sideLength() / (2 * sin(PI / this.numSides))\n  }\n\n  /** Get the area of a *regular* polygon */\n  area() {\n    return (this.numSides * this.sideLength() * this.apothem()) / 2\n  }\n\n  /** Return the normal of the face given by the face index */\n  normal() {\n    return getNormal(this.vectors)\n  }\n\n  isValid() {\n    return this.edges.every((e) => e.isValid())\n  }\n}\n","import { once } from \"lodash-es\"\nimport { Vector3, Ray, Matrix4 } from \"three\"\nimport { translateMat, getCentroid, withOrigin } from \"math/geom\"\nimport type Polyhedron from \"./Polyhedron\"\nimport type Vertex from \"./Vertex\"\n\nexport default abstract class Facet {\n  polyhedron: Polyhedron\n\n  constructor(polyhedron: Polyhedron) {\n    this.polyhedron = polyhedron\n  }\n\n  abstract normal(): Vector3\n\n  abstract get vertices(): Vertex[]\n\n  centroid = once(() => getCentroid(this.vertices.map((v) => v.vec)))\n\n  normalRay() {\n    return new Ray(this.centroid(), this.normal())\n  }\n\n  distanceToCenter() {\n    const origin = this.polyhedron.centroid()\n    return origin.distanceTo(this.centroid())\n  }\n\n  /** Get the rotation matrix for rotation around this face's normal */\n  rotateNormal(angle: number) {\n    return new Matrix4().makeRotationAxis(this.normal(), angle)\n  }\n\n  /** Get the matrix for translating a point the given amount in the direction of this normal */\n  translateNormal(amount: number) {\n    const scaled = this.normal().clone().setLength(amount)\n    return translateMat(scaled)\n  }\n\n  /** Return the given transform using this facet's centroid as origin */\n  withCentroidOrigin(mat: Matrix4) {\n    return withOrigin(this.centroid(), mat)\n  }\n}\n","import { angleBetween, getMidpoint, vecEquals } from \"math/geom\"\nimport Facet from \"./Facet\"\nimport type Vertex from \"./Vertex\"\nimport { find } from \"utils\"\n\nexport default class Edge extends Facet {\n  v1: Vertex\n  v2: Vertex\n\n  constructor(v1: Vertex, v2: Vertex) {\n    super(v1.polyhedron)\n    this.v1 = v1\n    this.v2 = v2\n  }\n\n  get value(): [number, number] {\n    return [this.v1.index, this.v2.index]\n  }\n\n  get vertices() {\n    return [this.v1, this.v2]\n  }\n\n  get face() {\n    return this.polyhedron.edgeToFaceGraph()[this.v1.index][this.v2.index]\n  }\n\n  prev() {\n    return find(this.face.edges, (e) => e.v2.equals(this.v1))\n  }\n\n  next() {\n    return find(this.face.edges, (e) => e.v1.equals(this.v2))\n  }\n\n  length() {\n    return this.v1.vec.distanceTo(this.v2.vec)\n  }\n\n  isValid() {\n    return !vecEquals(this.v1.vec, this.v2.vec)\n  }\n\n  midpoint() {\n    return this.centroid()\n  }\n\n  twin() {\n    return new Edge(this.v2, this.v1)\n  }\n\n  twinFace() {\n    return this.twin().face\n  }\n\n  // Get the \"undirected\" version of this edge, represented by\n  // the version where its vertices are ordered by their index\n  undirected() {\n    return this.v2.index > this.v1.index ? this : this.twin()\n  }\n\n  // Get the faces adjacent to this edge, with the directed face first\n  adjacentFaces() {\n    return [this.face, this.twin().face]\n  }\n\n  dihedralAngle() {\n    return angleBetween(\n      this.midpoint(),\n      this.face.centroid(),\n      this.twinFace().centroid(),\n    )\n  }\n\n  normal() {\n    return getMidpoint(this.face.normal(), this.twinFace().normal())\n  }\n\n  equals(edge: Edge) {\n    return this.v1.equals(edge.v1) && this.v2.equals(edge.v2)\n  }\n}\n","import { findKey, countBy } from \"lodash-es\"\nimport { Vector3 } from \"three\"\nimport { getCentroid } from \"math/geom\"\nimport { VIndex } from \"./solidTypes\"\nimport Facet from \"./Facet\"\nimport type Polyhedron from \"./Polyhedron\"\nimport Edge from \"./Edge\"\nimport { splitAt } from \"utils\"\n\nfunction getCycles<T>(array: T[]) {\n  return array.map((val, i) => {\n    const [front, back] = splitAt(array, i)\n    return [...back, ...front]\n  })\n}\n\nfunction arrayMin<T>(a1: T[], a2: T[]): T[] {\n  if (a1.length === 0) return a1\n  if (a2.length === 0) return a2\n  const [h1, ...t1] = a1\n  const [h2, ...t2] = a2\n  if (h1 < h2) return a1\n  if (h2 < h1) return a2\n  return [h1, ...arrayMin(t1, t2)]\n}\n\nexport default class Vertex extends Facet {\n  index: VIndex\n  vec: Vector3\n\n  constructor(polyhedron: Polyhedron, index: VIndex) {\n    super(polyhedron)\n    this.index = index\n    this.vec = polyhedron._solidData.vertices[index]\n  }\n\n  vertices = [this]\n\n  equals(other: Vertex) {\n    return this.index === other.index\n  }\n\n  inSet(vertices: Vertex[]) {\n    return vertices.some((vertex) => this.equals(vertex))\n  }\n\n  private *adjacentEdgesIter() {\n    const v2 = parseInt(findKey(this.polyhedron.edgeToFaceGraph()[this.index])!)\n    // TODO don't create a new edge?\n    const e0 = new Edge(this, this.polyhedron.vertices[v2])\n    let e = e0\n    let count = 0\n    do {\n      count++\n      yield e\n      e = e.prev().twin()\n      if (count > 10) throw new Error(\"we done messed up\")\n    } while (!e.equals(e0))\n  }\n\n  adjacentEdges() {\n    return [...this.adjacentEdgesIter()]\n  }\n\n  adjacentVertices() {\n    return this.adjacentEdges().map((e) => e.v2)\n  }\n\n  adjacentFaces() {\n    return this.adjacentEdges().map((e) => e.face)\n  }\n\n  configuration() {\n    const config = this.adjacentFaces().map((f) => f.numSides)\n    const allConfigs = getCycles(config).concat(\n      getCycles([...config].reverse()),\n    )\n    return allConfigs.reduce(arrayMin)\n  }\n\n  /** Return adjacent faces counted by number of sides */\n  adjacentFaceCounts() {\n    return countBy(this.adjacentFaces(), \"numSides\")\n  }\n\n  normal() {\n    return getCentroid(this.adjacentFaces().map((f) => f.normal())).normalize()\n  }\n}\n\nexport interface VertexList {\n  readonly vertices: Vertex[]\n  // TODO make this a more generic thing?\n  readonly polyhedron: Polyhedron\n}\n","import {\n  once,\n  set,\n  countBy,\n  maxBy,\n  minBy,\n  sortBy,\n  sum,\n  isEqual,\n} from \"lodash-es\"\nimport { Vector3 } from \"three\"\n\nimport { Point } from \"types\"\nimport { getSolidData } from \"data/common\"\nimport { polygons } from \"specs\"\nimport { getCentroid } from \"math/geom\"\n\nimport { SolidData, RawSolidData } from \"./solidTypes\"\nimport Face from \"./Face\"\nimport Vertex from \"./Vertex\"\nimport Edge from \"./Edge\"\nimport Cap from \"./Cap\"\nimport Builder from \"./SolidBuilder\"\nimport { VertexArg, FaceArg } from \"./SolidBuilder\"\nimport { find } from \"utils\"\nconst { PI, cbrt } = Math\n\nfunction calculateEdges(faces: Face[]) {\n  return faces\n    .flatMap((face) => face.edges)\n    .filter((e) => e.v1.index < e.v2.index)\n}\n\nexport default class Polyhedron {\n  _solidData: SolidData\n  faces: Face[]\n  vertices: Vertex[]\n  private _edges?: Edge[]\n\n  constructor(solidData: SolidData) {\n    this._solidData = solidData\n    this.vertices = solidData.vertices.map(\n      (vertex, vIndex) => new Vertex(this, vIndex),\n    )\n    this.faces = solidData.faces.map((face, fIndex) => new Face(this, fIndex))\n  }\n\n  static fromRawData(data: RawSolidData) {\n    return new Polyhedron({\n      ...data,\n      vertices: data.vertices.map((v) => new Vector3(...v)),\n    })\n  }\n\n  static get(name: string) {\n    return this.fromRawData(getSolidData(name))\n  }\n\n  get edges() {\n    if (!this._edges) {\n      this._edges = calculateEdges(this.faces)\n    }\n    return this._edges\n  }\n\n  get solidData() {\n    if (!this._solidData.edges) {\n      this._solidData.edges = this.edges.map((e) => e.value)\n    }\n    return this._solidData\n  }\n\n  rawSolidData(): RawSolidData {\n    return {\n      ...this.solidData,\n      vertices: this.vertices.map((v) => v.vec.toArray() as Point),\n    }\n  }\n\n  toString() {\n    return `Polyhedron { V=${this.numVertices()}, E=${this.numEdges()}, F=${this.numFaces()} }`\n  }\n\n  toJSON() {\n    return this.solidData\n  }\n\n  // Memoized mapping of edges to faces, used for quickly finding adjacency\n  edgeToFaceGraph = once(() => {\n    const edgesToFaces: NestedRecord<number, number, Face> = {}\n    for (const face of this.faces) {\n      for (const { v1, v2 } of face.edges) {\n        set(edgesToFaces, [v1.index, v2.index], face)\n      }\n    }\n    return edgesToFaces\n  })\n\n  // Simple properties\n  // =================\n\n  numVertices() {\n    return this.vertices.length\n  }\n\n  numFaces() {\n    return this.faces.length\n  }\n\n  numEdges() {\n    return this.edges.length\n  }\n\n  numFacesBySides() {\n    return countBy(this.faces, \"numSides\")\n  }\n\n  caps = once(() => Cap.getAll(this))\n\n  // Search functions\n  // ================\n\n  getVertex() {\n    return this.vertices[0]\n  }\n\n  getFace() {\n    return this.faces[0]\n  }\n\n  getEdge() {\n    return this.edges[0]\n  }\n\n  largestFace() {\n    return maxBy(this.faces, \"numSides\")!\n  }\n\n  smallestFace() {\n    return minBy(this.faces, \"numSides\")!\n  }\n\n  faceWithNumSides(n: number) {\n    return find(this.faces, (f) => f.numSides === n)\n  }\n\n  // The list of the type of faces this polyhedron has, ordered\n  faceTypes() {\n    return sortBy(Object.keys(this.numFacesBySides()))\n  }\n\n  vertexConfiguration() {\n    return countBy(\n      this.vertices.map((v) => v.configuration()),\n      (config) => config.join(\".\"),\n    )\n  }\n\n  // Geometric properties\n  // ====================\n\n  // Get the edge length of this polyhedron, assuming equal edges\n  edgeLength() {\n    return this.getFace().sideLength()\n  }\n\n  centroid() {\n    return getCentroid(this.vertices.map((v) => v.vec))\n  }\n\n  surfaceArea() {\n    return sum(this.faces.map((face) => face.area()))\n  }\n\n  normalizedSurfaceArea() {\n    return this.surfaceArea() / this.edgeLength() ** 2\n  }\n\n  volume() {\n    return sum(\n      this.faces.map((face) => (face.area() * face.distanceToCenter()) / 3),\n    )\n  }\n\n  normalizedVolume() {\n    return this.volume() / this.edgeLength() ** 3\n  }\n\n  sphericity() {\n    const v = this.volume()\n    const a = this.surfaceArea()\n    return (PI ** (1 / 3) * (6 * v) ** (2 / 3)) / a\n  }\n\n  /** Get the face that is closest to the given point. */\n  hitFace(point: Vector3) {\n    return minBy(this.faces, (face) =>\n      Math.abs(face.plane().distanceToPoint(point)),\n    )!\n  }\n\n  // Mutations\n  // =========\n\n  withChanges(changes: (b: Builder) => Builder) {\n    return changes(new Builder(this)).build()\n  }\n\n  // TODO support all the solid builder functions\n  // return a new polyhedron with the given vertices\n  withVertices(vertices: VertexArg[]) {\n    return this.withChanges((s) => s.withVertices(vertices))\n  }\n\n  withFaces(faces: FaceArg[]) {\n    return this.withChanges((s) => s.withFaces(faces))\n  }\n\n  withoutFaces(faces: Face[]) {\n    return this.withChanges((s) => s.withoutFaces(faces))\n  }\n\n  addPolyhedron(other: Polyhedron) {\n    return this.withChanges((s) => s.addPolyhedron(other))\n  }\n\n  /**\n   * Returns the reflection of this polyhedron on an axis\n   */\n  reflect() {\n    return this.withChanges((s) =>\n      s\n        .mapVertices((v) => new Vector3(-v.vec.x, v.vec.y, v.vec.z))\n        .mapFaces((f) => [...f.vertices.map((v) => v.index)].reverse()),\n    )\n  }\n\n  /** Center the polyhedron on its centroid. */\n  center() {\n    const centroid = this.centroid()\n    return this.withVertices(this.vertices.map((v) => v.vec.sub(centroid)))\n  }\n\n  normalizeToVolume(volume: number) {\n    const scale = cbrt(volume / this.volume())\n    return this.withVertices(\n      this.vertices.map((v) => v.vec.multiplyScalar(scale)),\n    )\n  }\n\n  isDeltahedron() {\n    const facesBySides = Object.keys(this.numFacesBySides())\n    return facesBySides.length === 1 && +facesBySides[0] === 3\n  }\n\n  faceAdjacencyList() {\n    const faceAdjacencyCounts = this.faces.map((face) => ({\n      n: face.numSides,\n      adj: face.adjacentFaceCounts(),\n    }))\n    return sortBy(\n      faceAdjacencyCounts,\n      [\"n\", \"adj.length\"].concat(polygons.map((n) => `adj[${n}]`)),\n    )\n  }\n\n  isSame(other: Polyhedron) {\n    return isEqual(this.faceAdjacencyList(), other.faceAdjacencyList())\n  }\n}\n","import { countBy } from \"lodash-es\"\n\nimport { getCyclic, flatMapUniq } from \"utils\"\nimport { VIndex, FIndex } from \"./solidTypes\"\nimport type Polyhedron from \"./Polyhedron\"\nimport FaceLike from \"./FaceLike\"\nimport Edge from \"./Edge\"\n\nexport default class Face extends FaceLike {\n  index: FIndex\n  value: VIndex[]\n\n  constructor(polyhedron: Polyhedron, index: FIndex) {\n    const value = polyhedron._solidData.faces[index]\n    const vertices = value.map((vIndex) => polyhedron.vertices[vIndex])\n    const edges = vertices.map(\n      (v, i) => new Edge(v, getCyclic(vertices, i + 1)),\n    )\n\n    super(vertices, edges)\n    this.index = index\n    this.value = value\n  }\n\n  // Return true if this face is the same as the given face (within a polyhedron)\n  equals(other: Face) {\n    return this.index === other.index\n  }\n\n  inSet(faces: readonly Face[]) {\n    return faces.some((face) => this.equals(face))\n  }\n\n  /** Return the set of faces that share a vertex to this face (including itself) */\n  vertexAdjacentFaces() {\n    return flatMapUniq(\n      this.vertices,\n      (vertex) => vertex.adjacentFaces(),\n      \"index\",\n    )\n  }\n\n  /** Return adjacent faces counted by number of sides */\n  adjacentFaceCounts() {\n    return countBy(this.adjacentFaces(), \"numSides\")\n  }\n}\n","import { Vector3 } from \"three\"\nimport { minBy, once, countBy, isEqual } from \"lodash-es\"\n\nimport { flatMapUniq, find } from \"utils\"\nimport { CapType } from \"specs\"\nimport Facet from \"./Facet\"\nimport type Polyhedron from \"./Polyhedron\"\nimport type Face from \"./Face\"\nimport type Vertex from \"./Vertex\"\nimport type Edge from \"./Edge\"\nimport FaceLike from \"./FaceLike\"\n\ntype FaceConfiguration = { [key: string]: number }\n\n// Find the boundary of a connected set of faces\nfunction getBoundary(faces: Face[]) {\n  const e0 = find(\n    faces.flatMap((f) => f.edges),\n    (e) => !e.twin().face.inSet(faces),\n  )!\n\n  const result: Edge[] = []\n  let e = e0\n  let count = 0\n  do {\n    if (count++ > 20) throw new Error(\"we done goofed\")\n    if (!e.twin().face.inSet(faces)) {\n      result.push(e)\n      const nextTwin = e.next().twin()\n      if (nextTwin.face.inSet(faces)) {\n        e = nextTwin.next()\n      } else {\n        e = e.next()\n      }\n    } else {\n      e = e.twin().next()\n    }\n  } while (!e.equals(e0))\n  return new FaceLike(\n    result.map((e) => e.v1),\n    result,\n  )\n}\n\ninterface Constructor<T> {\n  new (polyhedron: Polyhedron, arg: T): Cap\n}\nfunction createMapper<T>(mapper: (p: Polyhedron) => T[], Base: Constructor<T>) {\n  return (polyhedron: Polyhedron) => {\n    // const mapper = polyhedron[property]\n    const values: T[] = mapper(polyhedron)\n    return values\n      .map((arg) => new Base(polyhedron, arg))\n      .filter((cap) => cap.isValid())\n  }\n}\n\nexport default abstract class Cap extends Facet {\n  type: CapType\n  private _innerVertices: Vertex[]\n  private topPoint: Vector3\n  private faceConfiguration: FaceConfiguration\n\n  static find(polyhedron: Polyhedron, hitPoint: Vector3) {\n    const hitFace = polyhedron.hitFace(hitPoint)\n    const caps = polyhedron.caps().filter((cap) => hitFace.inSet(cap.faces()))\n    if (caps.length === 0) {\n      return null\n    }\n    return minBy(caps, (cap) => cap.topPoint.distanceToSquared(hitPoint))\n  }\n\n  static getAll(polyhedron: Polyhedron): Cap[] {\n    const pyramids = Pyramid.getAll(polyhedron)\n    if (pyramids.length > 0) return pyramids\n\n    const fastigium = Fastigium.getAll(polyhedron)\n    if (fastigium.length > 0) return fastigium\n\n    const cupolaRotunda = Cupola.getAll(polyhedron).concat(\n      Rotunda.getAll(polyhedron),\n    )\n    if (cupolaRotunda.length > 0) return cupolaRotunda\n    return []\n  }\n\n  constructor(\n    polyhedron: Polyhedron,\n    innerVertices: Vertex[],\n    type: CapType,\n    topPoint: Vector3,\n    faceConfiguration: FaceConfiguration,\n  ) {\n    super(polyhedron)\n    this._innerVertices = innerVertices\n    this.type = type\n    this.topPoint = topPoint\n    this.faceConfiguration = faceConfiguration\n  }\n\n  innerVertices() {\n    return this._innerVertices\n  }\n\n  get vertices() {\n    return this.allVertices()\n  }\n\n  allVertices = once(() => {\n    return this.innerVertices().concat(this.boundary().vertices)\n  })\n\n  faces = once(() => {\n    return flatMapUniq(this.innerVertices(), (v) => v.adjacentFaces(), \"index\")\n  })\n\n  boundary = once(() => {\n    return getBoundary(this.faces())\n  })\n\n  // NOTE for convenience, this calculates the centroid of the *boundary* not of all the vertices\n  centroid = () => this.boundary().centroid()\n\n  normal() {\n    return this.boundary().normal()\n  }\n\n  isValid() {\n    const matchFaces = this.innerVertices().every((vertex) => {\n      const faceCount = countBy(vertex.adjacentFaces(), \"numSides\")\n      return isEqual(faceCount, this.faceConfiguration)\n    })\n    return (\n      matchFaces &&\n      this.faces().every((face) => face.isValid()) &&\n      this.boundary().isPlanar()\n    )\n  }\n}\n\nclass Pyramid extends Cap {\n  constructor(polyhedron: Polyhedron, vertex: Vertex) {\n    super(polyhedron, [vertex], \"pyramid\", vertex.vec, {\n      \"3\": vertex.adjacentEdges().length,\n    })\n  }\n  static getAll = createMapper((p) => p.vertices, Pyramid)\n}\n\nclass Fastigium extends Cap {\n  constructor(polyhedron: Polyhedron, edge: Edge) {\n    const config = { \"3\": 1, \"4\": 2 }\n    super(polyhedron, edge.vertices, \"cupola\", edge.midpoint(), config)\n  }\n  static getAll = createMapper((p) => p.edges, Fastigium)\n}\n\nclass Cupola extends Cap {\n  constructor(polyhedron: Polyhedron, face: Face) {\n    super(\n      polyhedron,\n      face.vertices,\n      \"cupola\",\n      face.centroid(),\n      countBy([3, 4, 4, face.numSides]),\n    )\n  }\n  static getAll = createMapper((p) => p.faces, Cupola)\n}\n\nclass Rotunda extends Cap {\n  constructor(polyhedron: Polyhedron, face: Face) {\n    super(\n      polyhedron,\n      flatMapUniq(face.vertices, (v) => v.adjacentVertices(), \"index\"),\n      \"rotunda\",\n      face.centroid(),\n      { \"5\": 2, \"3\": 2 },\n    )\n  }\n  static getAll = createMapper((p) => p.faces, Rotunda)\n}\n","import { pullAt } from \"lodash-es\"\n\nimport { Vector3 } from \"three\"\nimport { VIndex, SolidData } from \"./solidTypes\"\nimport Vertex from \"./Vertex\"\nimport Face from \"./Face\"\nimport Polyhedron from \"./Polyhedron\"\n\nexport type VertexArg = Vector3 | Vertex\n\nexport type FaceArg = (VIndex | Vertex)[] | Face\n\nexport function normalizeVertex(v: VertexArg): Vector3 {\n  return v instanceof Vertex ? v.vec : v\n}\n\nfunction normalizeFace(face: FaceArg): VIndex[] {\n  if (Array.isArray(face)) {\n    return face.map((v) => {\n      if (typeof v === \"number\") return v\n      return v.index\n    })\n  }\n  return face.value\n}\n\nexport default class Builder {\n  polyhedron: Polyhedron\n  solidData: SolidData\n\n  constructor(polyhedron: Polyhedron) {\n    this.polyhedron = polyhedron\n    this.solidData = { ...polyhedron.solidData }\n  }\n\n  build() {\n    return new Polyhedron(this.solidData)\n  }\n\n  // return a new polyhedron with the given vertices\n  withVertices(vertices: VertexArg[]) {\n    this.solidData.vertices = vertices.map(normalizeVertex)\n    return this\n  }\n\n  // return a new polyhedron with the given faces\n  withFaces(faces: FaceArg[]) {\n    this.solidData.faces = faces.map(normalizeFace)\n    // reset edges, since faces might have changed\n    delete this.solidData.edges\n    return this\n  }\n\n  addVertices(vertices: Vertex[] | VertexArg[]) {\n    return this.withVertices(\n      (this.solidData.vertices as VertexArg[]).concat(vertices),\n    )\n  }\n\n  addFaces(faces: FaceArg[]) {\n    return this.withFaces((this.solidData.faces as FaceArg[]).concat(faces))\n  }\n\n  mapVertices(iteratee: (v: Vertex) => VertexArg) {\n    return this.withVertices(this.polyhedron.vertices.map(iteratee))\n  }\n\n  /** Map the faces of the *original* solid to new ones */\n  mapFaces(iteratee: (f: Face) => FaceArg) {\n    return this.withFaces(this.polyhedron.faces.map(iteratee))\n  }\n\n  withoutFaces(faces: Face[]) {\n    const removed = [...this.solidData.faces]\n    pullAt(\n      removed,\n      faces.map((f) => f.index),\n    )\n    return this.withFaces(removed)\n  }\n\n  addPolyhedron(other: Polyhedron) {\n    return this.addVertices(other.vertices).addFaces(\n      other.faces.map((face) =>\n        face.vertices.map((v) => v.index + this.polyhedron.numVertices()),\n      ),\n    )\n  }\n}\n","module.exports = __webpack_public_path__ + \"static/media/sad-scutoid.7909547f.png\";","import { BiMap } from \"bimap\"\nimport { allSolidNames } from \"data/common\"\nimport { getCanonicalSpecs } from \"specs\"\n\nfunction getConwayNotation(name: string) {\n  return getCanonicalSpecs(name).conwaySymbol()\n}\n\nconst conwayMapping = new BiMap(\n  allSolidNames.map((name) => [name, getConwayNotation(name)]),\n)\n\nexport function isConwayNotation(symbol: string) {\n  return conwayMapping.hasValue(symbol)\n}\n\nexport function fromConwayNotation(symbol: string) {\n  return conwayMapping.of(symbol)\n}\n","import React from \"react\"\nimport { Link } from \"react-router-dom\"\n\nimport { useStyle, fonts, scales, media } from \"styles\"\nimport { square, link } from \"styles/common\"\nimport image from \"images/sad-scutoid.png\"\nimport { usePageTitle } from \"components/common\"\n\nfunction Image() {\n  const css = useStyle(square(scales.size[5]))\n  return <img {...css()} src={image} alt=\"\" />\n}\n\nfunction Title() {\n  const css = useStyle({\n    textAlign: \"center\",\n    fontFamily: fonts.andaleMono,\n    fontSize: scales.font[3],\n    [media.mobile]: {\n      fontSize: scales.font[4],\n    },\n  })\n  return <h1 {...css()}>Uh oh! We don't know about that polyhedron!</h1>\n}\n\nfunction BackLink() {\n  const css = useStyle({\n    fontFamily: fonts.andaleMono,\n    fontSize: scales.font[4],\n    ...link,\n  })\n  return (\n    <Link {...css()} to=\"/\">\n      Go back\n    </Link>\n  )\n}\n\nexport default function ErrorPage() {\n  usePageTitle(\"Error - Polyhedra Viewer\")\n  const css = useStyle({\n    width: \"100vw\",\n    height: \"100vh\",\n\n    display: \"grid\",\n    gridGap: scales.spacing[2],\n    alignContent: \"center\",\n    justifyContent: \"center\",\n    justifyItems: \"center\",\n  })\n\n  return (\n    <section {...css()}>\n      <Image />\n      <Title />\n      <BackLink />\n    </section>\n  )\n}\n","import { PolyhedronSpecs } from \"specs\"\nimport { Polyhedron } from \"math/polyhedra\"\n\nexport default class PolyhedronForme<\n  Specs extends PolyhedronSpecs = PolyhedronSpecs\n> {\n  specs: Specs\n  geom: Polyhedron\n\n  constructor(specs: Specs, geom: Polyhedron) {\n    this.specs = specs\n    this.geom = geom\n  }\n}\n","import { takeRight, dropRight, invert, isEmpty, uniq } from \"lodash-es\"\nimport { Vector3, Matrix4 } from \"three\"\nimport { Polyhedron, Edge, Vertex, VertexList, VertexArg } from \"math/polyhedra\"\nimport { Transform, vecEquals, translateMat, scaleMat } from \"math/geom\"\nimport { mapObject } from \"utils\"\nimport { PolyhedronSpecs, Facet, Twist } from \"specs\"\n\nexport interface FacetOpts {\n  facet: Facet\n}\n\nexport interface TwistOpts {\n  twist: Twist\n}\n\n/**\n * Get the face opposite of the given edge, using the given \"twist\" option\n */\nexport function oppositeFace(edge: Edge, twist?: Twist) {\n  switch (twist) {\n    case \"left\":\n      return edge.twin().next().twin().prev().twinFace()\n    case \"right\":\n      return edge.twin().prev().twin().next().twinFace()\n    default:\n      // If no twist is provided, assume a square\n      return edge.twin().next().next().twinFace()\n  }\n}\n\n/**\n * Defines an orthonormal orientation.\n * An orientation [u, v] defineds the basis [u, v, u x v]\n */\ntype Orientation = readonly [Vector3, Vector3]\n\n/**\n * Defines a scale, origin, and orientation used to transform one polyhedron to another.\n */\nexport interface Pose {\n  scale: number\n  origin: Vector3\n  orientation: Orientation\n}\n\nfunction normalizeOrientation([u1, u2]: Orientation): Orientation {\n  const _u1 = u1.clone().normalize()\n  const _u2 = u2.clone().projectOnPlane(_u1).normalize()\n  return [_u1, _u2]\n}\n\nfunction getTransform({ origin, scale, orientation }: Pose) {\n  const [u1, u2] = normalizeOrientation(orientation)\n  const translateM = translateMat(origin)\n  const scaleM = scaleMat(scale)\n  const rotationM = new Matrix4().makeBasis(u1, u2, u1.clone().cross(u2))\n  return rotationM.premultiply(scaleM).premultiply(translateM)\n}\n\n// Translate, rotate, and scale the polyhedron with the transformation given by the two poses\nexport function alignPolyhedron(\n  solid: Polyhedron,\n  oldPose: Pose,\n  newPose: Pose,\n) {\n  const oldMat = getTransform(oldPose)\n  const newMat = getTransform(newPose)\n  const oldMatInv = oldMat.getInverse(oldMat)\n  // Un-apply the original pose, then apply the new pose\n  const newVertices = solid.vertices.map((v) =>\n    v.vec.clone().applyMatrix4(oldMatInv).applyMatrix4(newMat),\n  )\n  return solid.withVertices(newVertices)\n}\n\n/**\n * Return the Polyhedron geometry matching the given specs\n */\nexport function getGeometry(specs: PolyhedronSpecs) {\n  const geom = Polyhedron.get(specs.canonicalName())\n  // The reference models are always right-handed,\n  // so flip 'em if not\n  // TODO don't rely on this and make it more general\n  if (specs.isClassical() && specs.isSnub() && specs.data.twist === \"left\") {\n    return geom.reflect()\n  }\n\n  if (specs.isCapstone() && specs.isChiral()) {\n    if (specs.isCupolaRotunda() && specs.data.twist === \"left\") {\n      return geom.reflect()\n    } else if (!specs.isCupolaRotunda() && specs.data.twist === \"right\") {\n      return geom.reflect()\n    }\n  }\n  return geom\n}\n\n/**\n * Remove vertices in the polyhedron that aren't connected to any faces,\n * and remap the faces to the smaller indices\n */\nexport function removeExtraneousVertices(polyhedron: Polyhedron) {\n  // Vertex indices to remove\n  const vertsInFaces = polyhedron.faces.flatMap((f) => f.vertices)\n  const toRemove = polyhedron.vertices.filter((v) => !v.inSet(vertsInFaces))\n  const numToRemove = toRemove.length\n\n  // Map the `numToRemove` last vertices of the polyhedron (that don't overlap)\n  // to the first few removed vertices\n  const notToRemove = takeRight(polyhedron.vertices, numToRemove).filter(\n    (v) => !v.inSet(toRemove),\n  )\n  const newToOld = mapObject(notToRemove, (v, i) => [\n    v.index,\n    toRemove[i].index,\n  ])\n  const oldToNew = invert(newToOld)\n\n  const newVertices = dropRight(\n    polyhedron.vertices.map(\n      (v) => polyhedron.vertices[(oldToNew[v.index] as any) ?? v.index],\n    ),\n    numToRemove,\n  )\n\n  return polyhedron.withChanges((solid) =>\n    solid\n      .withVertices(newVertices)\n      .mapFaces((face) =>\n        face.vertices.map((v) => newToOld[v.index] ?? v.index),\n      ),\n  )\n}\n\n/** Remove vertices (and faces) from the polyhedron when they are all the same */\nexport function deduplicateVertices(polyhedron: Polyhedron) {\n  // group vertex indices by same\n  const unique: Vertex[] = []\n  const oldToNew: Record<number, number> = {}\n\n  polyhedron.vertices.forEach((v, vIndex) => {\n    const match = unique.find((point) => vecEquals(v.vec, point.vec))\n    if (match === undefined) {\n      unique.push(v)\n      oldToNew[vIndex] = vIndex\n    } else {\n      oldToNew[vIndex] = match.index\n    }\n  })\n\n  if (isEmpty(oldToNew)) return polyhedron\n\n  // replace vertices that are the same\n  const newFaces = polyhedron.faces\n    .map((face) => uniq(face.vertices.map((v) => oldToNew[v.index])))\n    .filter((vIndices) => vIndices.length >= 3)\n\n  // remove extraneous vertices\n  return removeExtraneousVertices(polyhedron.withFaces(newFaces))\n}\n\nfunction normalizeTransform(t: Transform | Vector3 | Matrix4): Transform {\n  if (t instanceof Matrix4) {\n    return (v) => v.clone().applyMatrix4(t)\n  }\n  if (t instanceof Vector3) {\n    return () => t\n  }\n  return t\n}\n\n/**\n * Apply a transformation per vertex list. This function allows transformations like\n * \"blow up these faces away from a center point\" or \"expand these faces out radially\".\n *\n * @param vLists The list of `VertexList`s to apply transformations to\n * @param iteratee the function to apply on each `VertexList` to generate a transform.\n * The function can either return a transform or a single vector value.\n * @param vertices The list of vertices to transform and return.\n * This defaults to the vertices of the polyhedron attached to the first `VertexList`.\n */\nexport function getTransformedVertices<T extends VertexList>(\n  vLists: readonly T[],\n  iteratee: (key: T) => Vector3 | Matrix4,\n  vertices: Vertex[] = vLists[0].polyhedron.vertices,\n) {\n  const result: VertexArg[] = [...vertices]\n  for (const vList of vLists) {\n    for (const v of vList.vertices) {\n      const t = normalizeTransform(iteratee(vList))\n      result[v.index] = t(v.vec)\n    }\n  }\n  return result\n}\n","import { find } from \"utils\"\nimport { Vector3 } from \"three\"\nimport {\n  Classical,\n  Facet,\n  facets,\n  oppositeFacet,\n  oppositeTwist,\n  getSpecs,\n} from \"specs\"\nimport { Polyhedron, Face } from \"math/polyhedra\"\nimport { angleBetween } from \"math/geom\"\nimport { getGeometry, oppositeFace } from \"math/operations/operationUtils\"\nimport PolyhedronForme from \"./PolyhedronForme\"\n\nexport default abstract class ClassicalForme extends PolyhedronForme<\n  Classical\n> {\n  static create(specs: Classical, geom: Polyhedron) {\n    switch (specs.data.operation) {\n      case \"regular\":\n        return new RegularForme(specs, geom)\n      case \"truncate\":\n        return new TruncatedForme(specs, geom)\n      case \"rectify\":\n        return new RectifiedForme(specs, geom)\n      case \"bevel\":\n        return new BevelledForme(specs, geom)\n      case \"cantellate\":\n        return new CantellatedForme(specs, geom)\n      case \"snub\":\n        return new SnubForme(specs, geom)\n    }\n  }\n\n  static fromSpecs(specs: Classical) {\n    return this.create(specs, getGeometry(specs))\n  }\n\n  static fromName(name: string) {\n    const specs = getSpecs(name)\n    if (!specs.isClassical()) throw new Error(`Invalid specs for name`)\n    return this.fromSpecs(specs)\n  }\n\n  faceType(facet: Facet): number {\n    return facet === \"vertex\" ? 3 : this.specs.data.family\n  }\n\n  /**\n   * Define a facet face for a non-tetrahedral solid\n   */\n  protected _isFacetFace(face: Face, facet: Facet) {\n    return face.numSides === this.faceType(facet)\n  }\n\n  /**\n   * Return whether the given face corresponds to the given facet\n   */\n  isFacetFace(face: Face, facet: Facet) {\n    if (this.specs.isTetrahedral()) {\n      return face.inSet(this.tetrahedralFacetFaces(facet))\n    }\n    // This should be overriden by subclasses\n    return this._isFacetFace(face, facet)\n  }\n\n  isAnyFacetFace(face: Face) {\n    return facets.some((facet) => this.isFacetFace(face, facet))\n  }\n\n  getFacet(face: Face) {\n    if (this.isFacetFace(face, \"vertex\")) return \"vertex\"\n    if (this.isFacetFace(face, \"face\")) return \"face\"\n    return null\n  }\n\n  facetFace(facet: Facet) {\n    return find(this.geom.faces, (face) => this.isFacetFace(face, facet))\n  }\n\n  /**\n   * Define the set of facet faces for a solid with tetrahedral symmetry.\n   */\n  // TODO I think there's another optimization here: tetrahedral faces can always be found\n  // using `adjacentFacetFace` so maybe we can use that instead?\n  protected abstract tetrahedralFacetFaces(facet: Facet): Face[]\n\n  facetFaces(facet: Facet) {\n    if (this.specs.isTetrahedral()) return this.tetrahedralFacetFaces(facet)\n    return this.geom.faces.filter((face) => this.isFacetFace(face, facet))\n  }\n\n  protected abstract adjacentFacetFace(face: Face, facet: Facet): Face\n\n  adjacentFacetFaces(facet: Facet) {\n    const f0 = this.facetFace(facet)\n    return [f0, this.adjacentFacetFace(f0, facet)]\n  }\n\n  mainFacet() {\n    return this.specs.facet()\n  }\n\n  minorFacet() {\n    return oppositeFacet(this.specs.facet())\n  }\n\n  isMainFacetFace(face: Face) {\n    return this.isFacetFace(face, this.mainFacet())\n  }\n\n  isMinorFacetFace(face: Face) {\n    return this.isFacetFace(face, this.minorFacet())\n  }\n\n  mainFacetFace() {\n    return this.facetFace(this.mainFacet())\n  }\n\n  mainFacetFaces() {\n    return this.facetFaces(this.mainFacet())\n  }\n\n  minorFacetFace() {\n    return this.facetFace(this.minorFacet())\n  }\n\n  minorFacetFaces() {\n    return this.facetFaces(this.minorFacet())\n  }\n\n  isEdgeFace(face: Face) {\n    return !this.isAnyFacetFace(face)\n  }\n\n  edgeFace() {\n    return find(this.geom.faces, (face) => this.isEdgeFace(face))\n  }\n\n  edgeFaces() {\n    return this.geom.faces.filter((f) => this.isEdgeFace(f))\n  }\n\n  /** Return the inradius of the given type of face */\n  inradius(facet: Facet) {\n    return this.facetFace(facet).distanceToCenter()\n  }\n\n  midradius(): number {\n    throw new Error(\n      `Polyhedron ${this.specs.name()} does not have consistent midradius`,\n    )\n  }\n\n  circumradius() {\n    return this.geom.getVertex().distanceToCenter()\n  }\n\n  /**\n   * Return the amount that this forme's faces are twisted\n   */\n  snubAngle(facet: Facet) {\n    return 0\n  }\n}\n\nclass RegularForme extends ClassicalForme {\n  _isFacetFace(face: Face, facet: Facet) {\n    return facet === this.specs.facet()\n  }\n\n  tetrahedralFacetFaces(facet: Facet) {\n    return facet === this.specs.facet() ? this.geom.faces : []\n  }\n\n  adjacentFacetFace(face: Face, facet: Facet) {\n    // NOTE this doesn't account for when the face isn't a facet face\n    return face.adjacentFaces()[0]\n  }\n\n  midradius() {\n    return this.geom.getEdge().distanceToCenter()\n  }\n}\n\nclass TruncatedForme extends ClassicalForme {\n  _isFacetFace(face: Face, facet: Facet) {\n    return this.specs.facet() === facet ? face.numSides > 5 : face.numSides <= 5\n  }\n\n  tetrahedralFacetFaces(facet: Facet) {\n    return this.geom.faces.filter(\n      (f) => f.numSides === (this.specs.facet() === facet ? 6 : 3),\n    )\n  }\n\n  adjacentFacetFace(face: Face, facet: Facet) {\n    return find(face.adjacentFaces(), (f) => this.isFacetFace(f, facet))\n  }\n}\n\nclass RectifiedForme extends ClassicalForme {\n  tetrahedralFacetFaces(facet: Facet) {\n    let f0 = this.geom.getFace()\n    if (facet === \"vertex\") {\n      f0 = f0.adjacentFaces()[0]\n    }\n    return [f0, ...f0.edges.map((e) => e.twin().prev().twinFace())]\n  }\n\n  adjacentFacetFace(face: Face, facet: Facet) {\n    return find(\n      face.vertices[0].adjacentFaces(),\n      (f) => this.isFacetFace(f, facet) && !f.equals(face),\n    )\n  }\n}\n\nclass BevelledForme extends ClassicalForme {\n  faceType(facet: Facet) {\n    return 2 * super.faceType(facet)\n  }\n\n  tetrahedralFacetFaces(facet: Facet) {\n    let f0 = this.geom.faceWithNumSides(6)\n    if (facet === \"vertex\") {\n      f0 = find(f0.adjacentFaces(), (f) => f.numSides === 6)\n    }\n    const rest = f0.edges\n      .filter((e) => e.twinFace().numSides === 4)\n      .map((e) => oppositeFace(e))\n    return [f0, ...rest]\n  }\n\n  adjacentFacetFace(face: Face, facet: Facet) {\n    return oppositeFace(\n      face.edges.filter((e) => this.isEdgeFace(e.twinFace()))[0],\n    )\n  }\n}\n\nclass CantellatedForme extends ClassicalForme {\n  _isFacetFace(face: Face, facet: Facet) {\n    return (\n      super._isFacetFace(face, facet) &&\n      face.adjacentFaces().every((f) => f.numSides === 4)\n    )\n  }\n\n  tetrahedralFacetFaces(facet: Facet) {\n    let f0 = this.geom.faceWithNumSides(3)\n    if (facet === \"vertex\") {\n      f0 = f0.edges[0].twin().next().twinFace()\n    }\n    return [f0, ...f0.edges.map((e) => oppositeFace(e))]\n  }\n\n  adjacentFacetFace(face: Face, facet: Facet) {\n    return oppositeFace(face.edges[0])\n  }\n}\n\nclass SnubForme extends ClassicalForme {\n  _isFacetFace(face: Face, facet: Facet) {\n    return (\n      super._isFacetFace(face, facet) &&\n      face.adjacentFaces().every((f) => f.numSides === 3)\n    )\n  }\n\n  tetrahedralFacetFaces = (facet: Facet) => {\n    let f0 = this.geom.faces[0]\n    const edge = f0.edges[0].twin()\n    let { twist } = this.specs.data\n    if (facet === \"vertex\") {\n      f0 = twist === \"left\" ? edge.prev().twinFace() : edge.next().twinFace()\n      twist = oppositeTwist(twist!)\n    }\n    return [f0, ...f0.edges.map((e) => oppositeFace(e, twist))]\n  }\n\n  adjacentFacetFace(face: Face, facet: Facet) {\n    let twist = this.specs.data.twist\n    if (facet === \"vertex\") twist = oppositeTwist(twist!)\n    return oppositeFace(face.edges[0], twist)\n  }\n\n  snubAngle(facet: Facet) {\n    const [face0, face1] = this.adjacentFacetFaces(facet)\n\n    // TODO this is fragile and relies on face1 being attached to face0.edges[0]\n    // Calculate the angle between the nearest apothem and the projected center of face1\n    const angle = angleBetween(\n      face0.centroid(),\n      face0.edges[0].midpoint(),\n      face0.plane().projectPoint(face1.centroid(), new Vector3()),\n    )\n\n    const twistSign = this.specs.data.twist === \"left\" ? -1 : 1\n    // if vertex-solid, reverse the sign\n    const facetSign = facet === \"vertex\" ? -1 : 1\n    return twistSign * facetSign * angle\n  }\n}\n","import PolyhedronForme from \"./PolyhedronForme\"\nimport { Capstone, getSpecs } from \"specs\"\nimport { Polyhedron, Face, Edge, Cap, FaceLike } from \"math/polyhedra\"\nimport { vecEquals, isInverse } from \"math/geom\"\nimport { getGeometry } from \"math/operations/operationUtils\"\nimport { find } from \"utils\"\n\ntype Base = Face | Cap | Edge\n\n// TODO add more useful functions here\nexport default abstract class CapstoneForme extends PolyhedronForme<Capstone> {\n  static create(specs: Capstone, geom: Polyhedron) {\n    switch (specs.data.count) {\n      case 0:\n        return specs.isSnub()\n          ? new SnubCapstoneForme(specs, geom)\n          : new PrismaticForme(specs, geom)\n      case 1:\n        return new MonoCapstoneForme(specs, geom)\n      case 2:\n        return new BiCapstoneForme(specs, geom)\n    }\n  }\n\n  static fromSpecs(specs: Capstone) {\n    return this.create(specs, getGeometry(specs))\n  }\n\n  static fromName(name: string) {\n    const specs = getSpecs(name)\n    if (!specs.isCapstone()) throw new Error(`Invalid specs for name`)\n    return this.fromSpecs(specs)\n  }\n\n  abstract bases(): readonly [Base, Base]\n\n  baseCaps() {\n    return this.bases().filter((base) => base instanceof Cap) as Cap[]\n  }\n\n  baseFaces() {\n    return this.bases().filter((base) => base instanceof Face) as Face[]\n  }\n\n  /**\n   * Return the `FaceLike` representation of this capstone's bases:\n   * either the face itself or the boundary of the cap.\n   */\n  baseBoundaries(): [FaceLike, FaceLike] {\n    return this.bases().map((base) =>\n      base instanceof Cap ? base.boundary() : base,\n    ) as [FaceLike, FaceLike]\n  }\n\n  prismaticHeight() {\n    const [top, bot] = this.baseBoundaries()\n    return top.centroid().distanceTo(bot.centroid())\n  }\n\n  /**\n   * Returns the base of the capstone that this face belongs to,\n   * or undefined if the face does not belong to a base.\n   */\n  baseOf(face: Face) {\n    return this.bases().find((base) => {\n      if (base instanceof Cap) {\n        return face.inSet(base.faces())\n      } else if (base instanceof Edge) {\n        return false\n      } else {\n        return face.equals(base)\n      }\n    })\n  }\n\n  /**\n   * Return whether the given face is in one of the bases of the cap.\n   */\n  inBase(face: Face) {\n    return !!this.baseOf(face)\n  }\n\n  /**\n   * Returns true if the face belongs to the top face of a capstone base.\n   */\n  isBaseTop(face: Face) {\n    const base = this.baseOf(face)\n    if (base instanceof Edge) return false\n    return base && vecEquals(face.normal(), base.normal())\n  }\n}\n\nclass PrismaticForme extends CapstoneForme {\n  bases() {\n    if (this.specs.isDigonal()) {\n      const edge1 = this.geom.getEdge()\n      const edge2 = find(this.geom.edges, (e) =>\n        isInverse(e.normal(), edge1.normal()),\n      )\n      return [edge1, edge2] as const\n    }\n    const face1 = this.geom.faceWithNumSides(this.specs.baseSides())\n    const face2 = find(this.geom.faces, (f) =>\n      isInverse(face1.normal(), f.normal()),\n    )\n    return [face1, face2] as const\n  }\n}\n\nclass SnubCapstoneForme extends CapstoneForme {\n  bases() {\n    if (this.specs.isDigonal()) {\n      const bases = this.geom.edges.filter((e) =>\n        e.vertices.every((v) => v.adjacentFaces().length === 4),\n      )\n      if (bases.length !== 2) throw new Error(`Invalid number of bases`)\n      return [bases[0], bases[1]] as const\n    }\n    // TODO dedupe with prismatic?\n    const face1 = this.geom.faceWithNumSides(this.specs.baseSides())\n    const face2 = find(this.geom.faces, (f) =>\n      isInverse(face1.normal(), f.normal()),\n    )\n    return [face1, face2] as const\n  }\n}\n\n// FIXME deal with fastigium\nclass MonoCapstoneForme extends CapstoneForme {\n  bases() {\n    const base = this.specs.isPrimary()\n      ? this.specs.data.base\n      : this.specs.data.base * 2\n    const face = this.geom.faceWithNumSides(base)\n    const cap = find(this.geom.caps(), (cap) =>\n      isInverse(cap.normal(), face.normal()),\n    )\n    return [cap, face] as const\n  }\n}\n\nclass BiCapstoneForme extends CapstoneForme {\n  bases() {\n    const caps = this.geom.caps()\n    for (const cap of this.geom.caps()) {\n      const cap2 = caps.find((cap2) => isInverse(cap.normal(), cap2.normal()))\n      if (!cap2) continue\n      // Favor the cupola over the rotunda as the \"top\" face\n      if (this.specs.isCupolaRotunda() && cap2.type === \"rotunda\") {\n        return [cap2, cap] as const\n      }\n      return [cap, cap2] as const\n    }\n    throw new Error(`Could not find opposite caps`)\n  }\n}\n","import { once } from \"lodash-es\"\nimport { find, getSingle } from \"utils\"\nimport PolyhedronForme from \"./PolyhedronForme\"\nimport { getGeometry } from \"math/operations/operationUtils\"\nimport { Composite, getSpecs } from \"specs\"\nimport { Polyhedron, Face, Cap } from \"math/polyhedra\"\nimport { getCentroid, isInverse } from \"math/geom\"\n\ntype Base = Cap | Face\n\nexport default abstract class CompositeForme extends PolyhedronForme<\n  Composite\n> {\n  static create(specs: Composite, geom: Polyhedron) {\n    // TODO lol maybe it's time for a visitor\n    if (specs.isAugmentedPrism()) {\n      return new AugmentedPrismForme(specs, geom)\n    } else if (specs.isAugmentedClassical()) {\n      return new AugmentedClassicalForme(specs, geom)\n    } else if (specs.isDiminishedSolid()) {\n      return new DiminishedSolidForme(specs, geom)\n    } else if (specs.isGyrateSolid()) {\n      return new GyrateSolidForme(specs, geom)\n    }\n    throw new Error(`Invalid composite specs: ${specs.name()}`)\n  }\n\n  static fromSpecs(specs: Composite) {\n    return this.create(specs, getGeometry(specs))\n  }\n\n  static fromName(name: string) {\n    const specs = getSpecs(name)\n    if (!specs.isComposite()) throw new Error(`Invalid specs for name`)\n    return this.fromSpecs(specs)\n  }\n\n  isAugmentedClassical(): this is AugmentedClassicalForme {\n    return this.specs.isAugmentedClassical()\n  }\n\n  isAugmentedPrism(): this is AugmentedPrismForme {\n    return this.specs.isAugmentedPrism()\n  }\n\n  isDiminishedSolid(): this is DiminishedSolidForme {\n    return this.specs.isDiminishedSolid()\n  }\n\n  isGyrateSolid(): this is GyrateSolidForme {\n    return this.specs.isGyrateSolid()\n  }\n\n  protected capInnerVertIndices = once(() => {\n    return new Set(\n      this.caps().flatMap((cap) => cap.innerVertices().map((v) => v.index)),\n    )\n  })\n\n  protected sourceVertices() {\n    return this.geom.vertices.filter(\n      (v) => !this.capInnerVertIndices().has(v.index),\n    )\n  }\n\n  /** Get the caps associated with this forme */\n  // FIXME this is confusing because it can be subclassed\n  caps() {\n    return this.geom.caps()\n  }\n\n  // FIXME implement this for diminished/gyrate\n  sourceCentroid() {\n    return getCentroid(this.sourceVertices().map((v) => v.vec))\n  }\n\n  /** Returns whether the given face is part of the source polyhedron (as opposed to a cap) */\n  isSourceFace(face: Face) {\n    return face.vertices.every((v) => !this.capInnerVertIndices().has(v.index))\n  }\n\n  /** Return whether this solid can be modified in a way that creates separate alignments */\n  hasAlignment() {\n    return this.specs.isMono()\n  }\n\n  abstract modifications(): Base[]\n\n  alignment(cap: Base) {\n    if (!this.hasAlignment()) return undefined\n    return isInverse(cap.normal(), getSingle(this.modifications()).normal())\n      ? \"para\"\n      : \"meta\"\n  }\n\n  abstract canAugment(face: Face): boolean\n}\n\nexport class AugmentedPrismForme extends CompositeForme {\n  hasAlignment() {\n    return super.hasAlignment() && this.specs.sourcePrism().isSecondary()\n  }\n\n  modifications() {\n    // FIXME make sure triangular prism doesn't count the fastigium\n    return this.caps()\n  }\n\n  baseFaces = once(() => {\n    if (this.specs.sourcePrism().isTriangular()) {\n      for (const face1 of this.geom.faces) {\n        for (const face2 of this.geom.faces) {\n          if (isInverse(face1.normal(), face2.normal())) {\n            return [face1, face2] as const\n          }\n        }\n      }\n      throw new Error(`Could not find base faces for ${this.specs.name()}`)\n    }\n\n    if (this.specs.sourcePrism().isSquare()) {\n      // FIXME why doesn't this work??\n      const face1 = this.geom.faceWithNumSides(4)\n      const face2 = find(this.geom.faces, (f) =>\n        isInverse(face1.normal(), f.normal()),\n      )\n      return [face1, face2] as const\n    }\n\n    return this.geom.faces.filter(\n      (f) => f.numSides === this.specs.sourcePrism().baseSides(),\n    ) as [Face, Face]\n  })\n\n  isBaseFace(face: Face) {\n    return face.inSet(this.baseFaces())\n  }\n\n  isSideFace(face: Face) {\n    // FIXME deal with square prism\n    return face.numSides === 4\n  }\n\n  canAugment(face: Face) {\n    if (!this.isSideFace(face)) return false\n    return this.caps().every((cap) =>\n      cap\n        .boundary()\n        .adjacentFaces()\n        .every((f) => !f.equals(face)),\n    )\n  }\n}\n\nexport class AugmentedClassicalForme extends CompositeForme {\n  hasAlignment() {\n    return super.hasAlignment() && this.specs.sourceClassical().isIcosahedral()\n  }\n\n  modifications() {\n    return this.caps()\n  }\n\n  caps() {\n    const caps = super.caps()\n    const specs = this.specs.sourceClassical()\n    // If it's an augmented tetrahedron, only consider the first cap\n    if (specs.isTetrahedral() && specs.isRegular()) {\n      return [caps[0]]\n    }\n    return caps\n  }\n\n  // Functions that exclusive to augmented solids\n\n  isMainFace(face: Face) {\n    // Only source faces re main faces\n    if (!this.isSourceFace(face)) return false\n    // All regular faces are main faces\n    if (this.specs.sourceClassical().isRegular()) return true\n    // It's a main face if it's not a truncated face\n    return face.numSides !== 3\n  }\n\n  mainFace() {\n    return find(this.geom.faces, (f) => this.isMainFace(f))\n  }\n\n  mainFaces() {\n    return this.geom.faces.filter((f) => this.isMainFace(f))\n  }\n\n  isMinorFace(face: Face) {\n    return this.isSourceFace(face) && !this.isMainFace(face)\n  }\n\n  minorFace() {\n    return find(this.geom.faces, (f) => this.isMinorFace(f))\n  }\n\n  minorFaces() {\n    return this.geom.faces.filter((f) => this.isMinorFace(f))\n  }\n\n  isCapTop(face: Face) {\n    if (this.specs.sourceClassical().isRegular()) return false\n    return face.vertices.every((v) => this.capInnerVertIndices().has(v.index))\n  }\n\n  capTops() {\n    return this.geom.faces.filter((f) => this.isCapTop(f))\n  }\n\n  canAugment(face: Face) {\n    if (!this.isMainFace(face)) return false\n    return this.caps().every((cap) =>\n      cap\n        .boundary()\n        .adjacentFaces()\n        .every((f) => !f.equals(face)),\n    )\n  }\n}\n\nexport class DiminishedSolidForme extends CompositeForme {\n  // FIXME dedupe with gyrate\n  isDiminishedFace(face: Face) {\n    return (\n      this.specs.isDiminished() &&\n      face.numSides === this.geom.largestFace().numSides\n    )\n  }\n\n  augmentedCaps() {\n    if (!this.specs.isAugmented()) return []\n    return this.caps().filter((cap) => cap.boundary().numSides === 3)\n  }\n\n  diminishedFaces() {\n    return this.geom.faces.filter((f) => this.isDiminishedFace(f))\n  }\n\n  isAugmentedFace(face: Face) {\n    if (!this.specs.isAugmented()) return false\n    return face.inSet(this.augmentedCaps()[0].faces())\n  }\n\n  modifications() {\n    return [...this.diminishedFaces(), ...this.augmentedCaps()]\n  }\n\n  canAugment(face: Face) {\n    if (this.specs.isAugmented()) return false\n    return (\n      this.isDiminishedFace(face) ||\n      face.adjacentFaces().every((f) => f.numSides === 5)\n    )\n  }\n}\n\nexport class GyrateSolidForme extends CompositeForme {\n  /** Return whether the given cap is gyrated */\n  isGyrate(cap: Cap) {\n    return cap.boundary().edges.every((edge) => {\n      const [n1, n2] = edge.adjacentFaces().map((f) => f.numSides)\n      return (n1 === 4) === (n2 === 4)\n    })\n  }\n\n  gyrateCaps() {\n    return this.geom.caps().filter((cap) => this.isGyrate(cap))\n  }\n\n  isDiminishedFace(face: Face) {\n    return (\n      this.specs.isDiminished() &&\n      face.numSides === this.geom.largestFace().numSides\n    )\n  }\n\n  diminishedFaces() {\n    return this.geom.faces.filter((f) => this.isDiminishedFace(f))\n  }\n\n  /**\n   * Returns the single diminished or gyrate face of this polyhedron.\n   */\n  modifications() {\n    return [...this.gyrateCaps(), ...this.diminishedFaces()]\n  }\n\n  canAugment(face: Face) {\n    return this.isDiminishedFace(face)\n  }\n}\n","import PolyhedronForme from \"./PolyhedronForme\"\nimport ClassicalForme from \"./ClassicalForme\"\nimport CapstoneForme from \"./CapstoneForme\"\nimport CompositeForme from \"./CompositeForme\"\n\nimport { PolyhedronSpecs } from \"specs\"\nimport { Polyhedron } from \"math/polyhedra\"\n\nexport default function createForme<Specs extends PolyhedronSpecs>(\n  specs: Specs,\n  geom: Polyhedron,\n): PolyhedronForme {\n  if (specs.isClassical()) return ClassicalForme.create(specs, geom)\n  if (specs.isCapstone()) return CapstoneForme.create(specs, geom)\n  if (specs.isComposite()) return CompositeForme.create(specs, geom)\n  // TODO ElementaryForme and others\n  return new PolyhedronForme(specs, geom)\n}\n","import { createHookedContext } from \"components/common\"\nimport PolyhedronForme from \"math/formes/PolyhedronForme\"\nimport createForme from \"math/formes/createForme\"\nimport { getSpecs } from \"specs\"\nimport { getGeometry } from \"math/operations/operationUtils\"\n\nconst defaultProps = { name: \"tetrahedron\" }\nexport default createHookedContext<\n  PolyhedronForme,\n  \"setPolyhedron\" | \"setPolyhedronToName\"\n>(\n  {\n    setPolyhedron: (forme) => () => forme,\n    setPolyhedronToName: (name) => (current) => {\n      const specs = getSpecs(name)\n      if (current.specs.canonicalName() === specs.canonicalName()) {\n        return createForme(specs, current.geom)\n      }\n      return createForme(specs, getGeometry(specs))\n    },\n  },\n  ({ name } = defaultProps) => {\n    const specs = getSpecs(name)\n    return createForme(specs, getGeometry(specs))\n  },\n)\n","import { Operation } from \"math/operations\"\nimport { createHookedContext } from \"components/common\"\n\nconst defaultState = {\n  operation: undefined,\n  options: undefined,\n}\n\ntype Options = Record<string, any>\ninterface State {\n  operation?: Operation<Options>\n  options?: Options\n}\n\ntype Actions = \"setOperation\" | \"unsetOperation\" | \"setOption\"\n\nexport default createHookedContext<State, Actions>(\n  {\n    setOperation: (operation, solid) => () => {\n      return { operation, options: operation.defaultOptions(solid) }\n    },\n    unsetOperation: () => () => {\n      return defaultState\n    },\n    setOption: (name, value) => ({ operation, options }) => {\n      return { operation, options: { ...options, [name]: value } }\n    },\n  },\n  defaultState,\n)\n","import { noop } from \"lodash-es\"\n\nimport { Vector3, Color } from \"three\"\nimport React, { useRef, useEffect, useContext, useCallback } from \"react\"\nimport { ChildrenProp } from \"types\"\n\nimport { createHookedContext } from \"components/common\"\nimport Config from \"components/ConfigCtx\"\nimport PolyhedronCtx from \"./PolyhedronCtx\"\nimport transition from \"transition\"\nimport { Polyhedron, SolidData } from \"math/polyhedra\"\nimport { AnimationData } from \"math/operations\"\n\n// Get the colors for each face given our current configuration\nfunction getFaceColors(mapping: number[], colors: any) {\n  return mapping.map((f) => new Color(colors[f]))\n}\n\nconst defaultState = {\n  solidData: undefined,\n  faceColors: undefined,\n  isTransitioning: false,\n}\ninterface State {\n  solidData?: SolidData\n  faceColors?: any[]\n  isTransitioning: boolean\n}\nconst InterpModel = createHookedContext<State, \"set\" | \"reset\">(\n  {\n    reset: () => () => defaultState,\n    set: (solidData, faceColors) => () => ({\n      solidData,\n      faceColors,\n      isTransitioning: !!solidData,\n    }),\n  },\n  defaultState,\n)\n\nconst TransitionContext = React.createContext(noop)\n\nfunction InnerProvider({ children }: ChildrenProp) {\n  const transitionId = useRef<ReturnType<typeof transition> | null>(null)\n  const { setPolyhedron } = PolyhedronCtx.useActions()\n  const config = Config.useState()\n  const { colors, animationSpeed, enableAnimation } = config\n  const anim = InterpModel.useActions()\n\n  // Cancel the animation if the component we're a part of gets rerendered.\n  useEffect(() => {\n    return () => {\n      if (transitionId.current) {\n        transitionId.current.cancel()\n      }\n    }\n  }, [transitionId])\n  const transitionFn = useCallback(\n    (result: Polyhedron, animationData: AnimationData) => {\n      if (!enableAnimation || !animationData) {\n        setPolyhedron(result)\n        anim.reset()\n        return\n      }\n\n      const { start, endVertices, startColors, endColors } = animationData\n      const startFaceColors = getFaceColors(startColors, colors)\n      const endFaceColors = getFaceColors(endColors, colors)\n      anim.set(start.solidData, startFaceColors)\n      function lerpColors(t: number) {\n        return startFaceColors.map((color, i) =>\n          color.clone().lerp(endFaceColors[i], t),\n        )\n      }\n      transitionId.current = transition(\n        {\n          duration: 1000 / animationSpeed,\n          ease: \"easeQuadInOut\",\n          onFinish: () => {\n            setPolyhedron(result)\n            anim.reset()\n          },\n        },\n        (t) => {\n          // TODO update the vectors instead of creating new ones and updating state each time\n          anim.set(\n            {\n              ...start.solidData,\n              vertices: start.vertices.map((v, i) =>\n                new Vector3().lerpVectors(v.vec, endVertices[i], t),\n              ),\n            },\n            lerpColors(t),\n          )\n        },\n      )\n    },\n    [anim, animationSpeed, colors, enableAnimation, setPolyhedron],\n  )\n\n  return (\n    <TransitionContext.Provider value={transitionFn}>\n      {children}\n    </TransitionContext.Provider>\n  )\n}\n\nfunction Provider({ children }: ChildrenProp) {\n  return (\n    <InterpModel.Provider>\n      <InnerProvider>{children}</InnerProvider>\n    </InterpModel.Provider>\n  )\n}\n\nfunction useTransition() {\n  return useContext(TransitionContext)\n}\n\nexport default {\n  Provider,\n  useState: InterpModel.useState,\n  useTransition,\n}\n","import * as d3 from \"d3-ease\"\n\nexport interface TransitionOptions {\n  duration: number\n  ease: keyof typeof d3\n  onFinish(): void\n}\n\nexport type Callback = (val: number) => void\n\n/**\n * An animation function based on d3's interpolate.\n * @returns an cancel() function\n */\nexport default function transition(\n  options: TransitionOptions,\n  updateCallback: Callback,\n) {\n  const {\n    // Duration, in milliseconds\n    duration,\n    ease,\n    onFinish,\n  } = options\n  let start = 0\n  const id: { current?: number } = {}\n  // Adapted from:\n  // https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\n  const step = (timestamp: number) => {\n    if (!start) {\n      start = timestamp\n    }\n    const delta = timestamp - start\n    const progress = Math.min(delta / duration, 1)\n    updateCallback(d3[ease](progress))\n    if (delta < duration) {\n      id.current = requestAnimationFrame(step)\n    } else {\n      onFinish?.()\n    }\n  }\n  id.current = requestAnimationFrame(step)\n  return {\n    cancel() {\n      cancelAnimationFrame(id.current!)\n    },\n  }\n}\n","import { useCallback } from \"react\"\nimport { Operation } from \"math/operations\"\nimport { Polyhedron } from \"math/polyhedra\"\nimport PolyhedronCtx from \"./PolyhedronCtx\"\nimport OperationCtx from \"./OperationCtx\"\nimport TransitionCtx from \"./TransitionCtx\"\n\ntype ResultCallback = (polyhedron: Polyhedron) => void\n\n// TODO figure out stricter typing here\ntype Options = any\nexport default function useApplyOperation() {\n  const { setOperation, unsetOperation } = OperationCtx.useActions()\n  const polyhedron = PolyhedronCtx.useState()\n  const transition = TransitionCtx.useTransition()\n\n  const applyOperation = useCallback(\n    (\n      operation: Operation<Options>,\n      options: Options = {},\n      callback?: ResultCallback,\n    ) => {\n      if (!operation) throw new Error(\"no operation defined\")\n\n      const { result, animationData } = operation.apply(polyhedron, options)\n      // If the current operation has options and the result has options,\n      // keep the options set\n      if (\n        operation.hasOptions(polyhedron) &&\n        operation.canApplyTo(result) &&\n        operation.hasOptions(result)\n      ) {\n        setOperation(operation, result)\n      } else {\n        unsetOperation()\n      }\n\n      transition(result, animationData)\n      callback?.(result.geom)\n    },\n    [polyhedron, transition, setOperation, unsetOperation],\n  )\n\n  return applyOperation\n}\n","import { isMatch, pickBy } from \"lodash-es\"\nimport { find } from \"utils\"\nimport { PolyhedronSpecs } from \"specs\"\nimport { VertexArg } from \"math/polyhedra\"\nimport {\n  OpArgs,\n  SolidArgs,\n  GraphEntry as DirectedGraphEntry,\n} from \"./Operation\"\nimport { Pose, alignPolyhedron, getGeometry } from \"./operationUtils\"\nimport PolyhedronForme from \"math/formes/PolyhedronForme\"\nimport createForme from \"math/formes/createForme\"\n\nexport type Side = \"left\" | \"right\"\n\nfunction oppositeSide(side: Side) {\n  return side === \"left\" ? \"right\" : \"left\"\n}\n\nexport interface GraphOpts<L, R> {\n  left: L\n  right: R\n}\n\n// TODO ugh this is still ugly\nexport interface GraphEntry<Specs, L, R> {\n  left: Specs\n  right: Specs\n  options?: GraphOpts<L, R>\n}\n\nexport function toDirected<S extends Side, Specs, L, R>(\n  side: S,\n  graph: () => Generator<GraphEntry<Specs, L, R>>,\n): () => Generator<DirectedGraphEntry<Specs, Opts<S, L, R>>> {\n  return function* () {\n    for (const entry of graph()) {\n      yield {\n        start: entry[side],\n        end: entry[oppositeSide(side)],\n        options: entry.options?.[side] as any,\n      }\n    }\n  }\n}\n\nexport type GraphGenerator<Specs, L, R> = Generator<GraphEntry<Specs, L, R>>\n\ntype MiddleGetter<Forme extends PolyhedronForme, L, R> = (\n  entry: GraphEntry<Forme[\"specs\"], L, R>,\n) => Forme[\"specs\"] | Forme\n\nexport interface OpPairInput<Forme extends PolyhedronForme, L = {}, R = L> {\n  // The graph of what polyhedron spec inputs are allowed and what maps to each other\n  graph(): GraphGenerator<Forme[\"specs\"], L, R>\n  // Get the intermediate polyhedron for the given graph entry\n  middle: Side | MiddleGetter<Forme, L, R>\n  // Get the post of a left, right, or middle state\n  getPose(pos: Side | \"middle\", solid: Forme, opts: GraphOpts<L, R>): Pose\n  // Move the intermediate figure to the left position\n  toLeft?(\n    solid: Forme,\n    opts: GraphOpts<L, R>,\n    result: Forme[\"specs\"],\n  ): VertexArg[]\n  // Move the intermediate figure to the right position\n  toRight?(\n    solid: Forme,\n    opts: GraphOpts<L, R>,\n    result: Forme[\"specs\"],\n  ): VertexArg[]\n}\n\nfunction defaultGetter<Specs extends PolyhedronSpecs>({\n  geom,\n}: SolidArgs<Specs>) {\n  return geom.vertices\n}\n\ntype Opts<S extends Side, L, R> = S extends \"left\" ? L : R\n\nclass OpPair<\n  Forme extends PolyhedronForme,\n  L extends {} = {},\n  R extends {} = L\n> {\n  inputs: OpPairInput<Forme, L, R>\n  graph: GraphEntry<Forme[\"specs\"], L, R>[]\n\n  constructor(inputs: OpPairInput<Forme, L, R>) {\n    this.inputs = inputs\n    this.graph = [...this.inputs.graph()]\n  }\n\n  private getEntries(side: Side, specs: Forme[\"specs\"]) {\n    return this.graph.filter((entry) => entry[side].equals(specs))\n  }\n\n  findEntry<S extends Side>(\n    side: S,\n    specs: Forme[\"specs\"],\n    opts?: Opts<S, L, R>,\n  ) {\n    return this.graph.find(\n      (entry) =>\n        entry[side].equals(specs) &&\n        isMatch(entry.options?.[side] ?? {}, opts ?? {}),\n    )\n  }\n\n  getEntry<S extends Side>(\n    side: S,\n    specs: Forme[\"specs\"],\n    opts?: Opts<S, L, R>,\n  ) {\n    const entry = this.findEntry(side, specs, opts)\n    if (!entry)\n      throw new Error(\n        `Could not find ${side} entry with specs: ${specs.name()}, opts: ${JSON.stringify(\n          opts,\n        )}`,\n      )\n    return entry\n  }\n\n  hasOptions(side: Side, specs: Forme[\"specs\"]) {\n    return this.getEntries(side, specs).length > 1\n  }\n\n  *allOptions<S extends Side>(\n    side: S,\n    specs: Forme[\"specs\"],\n  ): Generator<Opts<S, L, R>> {\n    for (const entry of this.getEntries(side, specs)) {\n      yield (entry.options?.[side] ?? {}) as Opts<S, L, R>\n    }\n  }\n\n  canApplyTo(side: Side, specs: PolyhedronSpecs) {\n    return !!this.findEntry(side, specs as Forme[\"specs\"])\n  }\n\n  getOpposite<S extends Side>(\n    side: S,\n    specs: Forme[\"specs\"],\n    options?: Opts<S, L, R>,\n  ) {\n    return this.getEntry(side, specs, options)[oppositeSide(side)]\n  }\n\n  apply<S extends Side>(side: S, solid: Forme, opts: Opts<S, L, R>) {\n    const {\n      middle: getMiddle,\n      getPose,\n      toLeft = defaultGetter,\n      toRight = defaultGetter,\n    } = this.inputs\n    const entry = this.getEntry(side, solid.specs, opts)\n    const options =\n      entry.options ?? ({ left: {}, right: {} } as GraphOpts<L, R>)\n    const solidForme = createForme(solid.specs, solid.geom) as Forme\n    const startPose = getPose(side, solidForme, options)\n\n    const endSide = oppositeSide(side)\n    const endSpecs = entry[endSide]\n    const endGeom = getGeometry(endSpecs)\n    const alignedEnd = alignPolyhedron(\n      endGeom,\n      getPose(endSide, createForme(endSpecs, endGeom) as Forme, options),\n      startPose,\n    )\n\n    let middle\n    if (typeof getMiddle === \"string\") {\n      // If we receive a Side argument, set the middle to whichever end polyhedron\n      // matches the side\n      middle =\n        getMiddle === side\n          ? solidForme\n          : (createForme(endSpecs, alignedEnd) as Forme)\n    } else {\n      // Otherwise, we have to fetch the intermediate solid ourselves\n      // const middleSolid = normalizeIntermediate(getMiddle(entry))\n      const inter = getMiddle(entry)\n      const middleSolid =\n        inter instanceof PolyhedronSpecs\n          ? (createForme(inter, getGeometry(inter)) as Forme)\n          : inter\n\n      const alignedInter = alignPolyhedron(\n        middleSolid.geom,\n        getPose(\"middle\", middleSolid, options),\n        startPose,\n      )\n      middle = createForme(middleSolid.specs, alignedInter) as Forme\n    }\n\n    const [startFn, endFn] =\n      side === \"left\" ? [toLeft, toRight] : [toRight, toLeft]\n\n    return {\n      animationData: {\n        start: middle.geom.withVertices(startFn(middle, options, solid.specs)),\n        endVertices: endFn(middle, options, endSpecs),\n      },\n      result: alignedEnd,\n    }\n  }\n}\n\nexport type OpInput<O, F extends PolyhedronForme, GO = O> = Required<\n  Pick<OpArgs<O, F, GO>, \"apply\" | \"graph\" | \"toGraphOpts\">\n>\n\n/**\n * Turn an operation pair into the one-way operation corresponding to the given side\n */\nfunction makeOperation<S extends Side, Forme extends PolyhedronForme, L, R>(\n  side: S,\n  op: OpPair<Forme, L, R>,\n): OpInput<Opts<S, L, R>, Forme> {\n  return {\n    apply(solid, opts) {\n      return op.apply(side, solid, opts)\n    },\n    graph: toDirected(side, op.inputs.graph),\n    toGraphOpts(forme, opts) {\n      return opts\n    },\n  }\n}\n\n/**\n * Takes the given input and creates a pair of inverse operations.\n */\nexport function makeOpPair<Forme extends PolyhedronForme, L = {}, R = L>(\n  opInput: OpPairInput<Forme, L, R>,\n) {\n  const op = new OpPair(opInput)\n  return { left: makeOperation(\"left\", op), right: makeOperation(\"right\", op) }\n}\n\nexport function combineOps<F extends PolyhedronForme, O, GO extends {} = O>(\n  opArgs: OpInput<O, F, GO>[],\n): OpInput<O, F, GO> {\n  function getOp(solid: F, options: O) {\n    // FIXME This is the same logic in Operation for finding the entry\n    return find(opArgs, (op) =>\n      [...op.graph()].some(\n        (entry) =>\n          entry.start.equals(solid.specs) &&\n          isMatch(entry.options ?? {}, pickBy(op.toGraphOpts(solid, options))),\n      ),\n    )\n  }\n  return {\n    graph: function* () {\n      for (const op of opArgs) {\n        yield* op.graph()\n      }\n    },\n    apply(solid, opts) {\n      return getOp(solid, opts).apply(solid, opts)\n    },\n    toGraphOpts(solid, opts) {\n      return getOp(solid, opts).toGraphOpts(solid, opts)\n    },\n  }\n}\n","import { Vector3 } from \"three\"\nimport { pickBy, mapValues, isMatch, compact } from \"lodash-es\"\n\nimport { vecEquals } from \"math/geom\"\nimport { Polyhedron, Face, VertexArg, normalizeVertex } from \"math/polyhedra\"\nimport { deduplicateVertices } from \"./operationUtils\"\nimport { Polygon, PolyhedronSpecs } from \"specs\"\nimport PolyhedronForme from \"math/formes/PolyhedronForme\"\nimport createForme from \"math/formes/createForme\"\nimport { find, EntryIters, cartesian } from \"utils\"\n\ntype SelectState = \"selected\" | \"selectable\" | undefined\n\nexport interface AnimationData {\n  start: Polyhedron\n  endVertices: Vector3[]\n  startColors: Polygon[]\n  endColors: Polygon[]\n}\n\nexport interface OpResult {\n  result: PolyhedronForme\n  animationData: AnimationData\n}\n\ninterface PartialOpResult {\n  result?: Polyhedron\n  animationData: {\n    start: Polyhedron\n    endVertices: VertexArg[]\n  }\n}\n\nexport interface SolidArgs<Specs extends PolyhedronSpecs> {\n  specs: Specs\n  geom: Polyhedron\n}\n\nexport interface GraphEntry<Specs, Opts> {\n  start: Specs\n  end: Specs\n  options?: Opts\n}\n\nexport interface OpArgs<\n  Options extends {},\n  Forme extends PolyhedronForme,\n  GraphOpts = Options\n> {\n  graph(): Generator<GraphEntry<Forme[\"specs\"], GraphOpts>>\n\n  toGraphOpts(solid: Forme, opts: Options): GraphOpts\n\n  hasOptions?(info: Forme[\"specs\"]): boolean\n\n  apply(solid: Forme, options: Options): PartialOpResult\n\n  /** Return an iterator of all possible options of each polyhedron */\n  allOptions?(solid: Forme): EntryIters<Options>\n\n  hitOption?: keyof Options\n\n  getHitOption?(\n    solid: Forme,\n    hitPnt: Vector3,\n    options: Partial<Options>,\n  ): Partial<Options>\n\n  defaultOptions?(info: Forme[\"specs\"]): Partial<Options>\n\n  selectionState?(face: Face, solid: Forme, options: Options): SelectState\n}\n\ntype OperationArg = keyof OpArgs<any, any>\nconst methodDefaults = {\n  getHitOption: {},\n  defaultOptions: {},\n}\n\n// TODO get this to return the correct type\nfunction fillDefaults<Options extends {}, Forme extends PolyhedronForme>(\n  op: OpArgs<Options, Forme, any>,\n): Required<OpArgs<Options, Forme>> {\n  return {\n    ...mapValues(\n      methodDefaults,\n      (fnDefault, fn: OperationArg) => op[fn] ?? (() => fnDefault),\n    ),\n    ...op,\n  } as Required<OpArgs<Options, Forme>>\n}\n\nfunction getCoplanarFaces(polyhedron: Polyhedron) {\n  const found: Face[] = []\n  const pairs: [Face, Face][] = []\n  polyhedron.faces.forEach((f1) => {\n    if (f1.inSet(found) || !f1.isValid()) return\n\n    f1.adjacentFaces().forEach((f2) => {\n      if (!f2 || !f2.isValid()) return\n      if (vecEquals(f1.normal(), f2.normal())) {\n        pairs.push([f1, f2])\n        found.push(f1)\n        found.push(f2)\n        return\n      }\n    })\n  })\n  return pairs\n}\n\nfunction getFaceColors(polyhedron: Polyhedron): Polygon[] {\n  const pairs = getCoplanarFaces(polyhedron)\n  const mapping: Record<number, Polygon> = {}\n  for (const [f1, f2] of pairs) {\n    const numSides = (f1.numSides + f2.numSides - 2) as Polygon\n    mapping[f1.index] = numSides\n    mapping[f2.index] = numSides\n  }\n\n  return polyhedron.faces.map(\n    (face) => mapping[face.index] ?? face.numUniqueSides(),\n  )\n}\n\nfunction arrayDefaults(first: Polygon[], second: Polygon[]) {\n  return first.map((item, i) => (item >= 3 ? item : second[i]))\n}\n\nfunction normalizeOpResult(\n  opResult: PartialOpResult,\n  newSpecs: PolyhedronSpecs,\n): OpResult {\n  const { result, animationData } = opResult\n  const { start, endVertices } = animationData\n\n  const end = start.withVertices(endVertices)\n  const normedResult = result ?? deduplicateVertices(end)\n\n  // Populate the how the faces in the start and end vertices should be colored\n  const startColors = getFaceColors(start)\n  const endColors = getFaceColors(end)\n\n  return {\n    result: createForme(newSpecs, normedResult),\n    animationData: {\n      start,\n      endVertices: endVertices.map(normalizeVertex),\n      startColors: arrayDefaults(startColors, endColors),\n      endColors: arrayDefaults(endColors, startColors),\n    },\n  }\n}\n\nexport default class Operation<Options extends {} = {}> {\n  name: string\n  graph: GraphEntry<PolyhedronSpecs, Options>[]\n  hitOption: keyof Options\n  private opArgs: Required<OpArgs<Options, PolyhedronForme>>\n\n  constructor(name: string, opArgs: OpArgs<Options, PolyhedronForme, any>) {\n    this.name = name\n    this.opArgs = fillDefaults(opArgs)\n    this.graph = [...this.opArgs.graph()]\n    this.hitOption = this.opArgs.hitOption\n  }\n\n  apply(solid: PolyhedronForme, options: Options) {\n    // get the next polyhedron name\n    const next = this.getResult(solid, options)\n\n    // Get the actual operation result\n    const opResult = this.opArgs.apply(solid, options ?? {})\n    return normalizeOpResult(opResult, next)\n  }\n\n  getHitOption(solid: PolyhedronForme, hitPnt: Vector3, options: Options) {\n    return this.opArgs.getHitOption(solid, hitPnt, options)\n  }\n\n  canApplyTo(solid: PolyhedronForme) {\n    return this.graph.some((entry) => entry.start.equals(solid.specs))\n  }\n\n  getEntry(solid: PolyhedronForme, options: Options) {\n    // FIXME optimize this and make error checking better\n    // e.g. make it easier to type.\n    return find(\n      this.graph,\n      (entry) =>\n        entry.start.equals(solid.specs) &&\n        isMatch(\n          entry.options ?? {},\n          pickBy(this.opArgs.toGraphOpts(solid, options)),\n        ),\n    )\n  }\n\n  getEntries(solid: PolyhedronForme) {\n    return this.graph.filter((entry) => entry.start.equals(solid.specs))\n  }\n\n  getResult(solid: PolyhedronForme, options: Options) {\n    return this.getEntry(solid, options).end\n  }\n\n  hasOptions(solid: PolyhedronForme) {\n    if (this.opArgs.hasOptions) {\n      return this.opArgs.hasOptions(solid.specs)\n    }\n    return this.getEntries(solid).length > 1\n  }\n\n  allOptions(solid: PolyhedronForme, optionName: keyof Options) {\n    if (!this.opArgs.allOptions)\n      throw new Error(\n        `Operation ${this.name} does not support getting individual options`,\n      )\n    return compact([...this.opArgs.allOptions(solid)[optionName]])\n  }\n\n  /**\n   * (Testing utility)\n   * Return all possible options that can be used to apply this operation on the given solid.\n   */\n  *allOptionCombos(solid: PolyhedronForme) {\n    if (!this.opArgs.allOptions) {\n      // If allOptions is not defined, default to listing the options of the solid graph\n      for (const entry of this.getEntries(solid)) {\n        yield entry.options\n      }\n    } else {\n      return cartesian(this.opArgs.allOptions(solid))\n    }\n  }\n\n  defaultOptions(solid: PolyhedronForme) {\n    return this.opArgs.defaultOptions(solid.specs)\n  }\n\n  selectionState(face: Face, solid: PolyhedronForme, options: Options) {\n    return this.opArgs.selectionState?.(face, solid, options)\n  }\n}\n\nexport function makeOperation<\n  Options extends {} = {},\n  Forme extends PolyhedronForme = PolyhedronForme,\n  GraphOpts = Options\n>(name: string, opArgs: OpArgs<Options, Forme, GraphOpts>) {\n  return new Operation(name, opArgs)\n}\n","import { Vector3 } from \"three\"\nimport { Face, Edge, VertexArg } from \"math/polyhedra\"\nimport Classical, { Operation as OpName } from \"specs/Classical\"\nimport { makeOpPair } from \"../operationPairs\"\nimport { angleBetween } from \"math/geom\"\nimport { Pose } from \"../operationUtils\"\nimport ClassicalForme from \"math/formes/ClassicalForme\"\nconst { PI, tan } = Math\n\n/**\n * Returns the point to sharpen given parameters in the following setup:\n *      result\n *      / ^\n *     /  |\n *   p2___f.normal\n *   /\n * p1\n *\n */\nexport function getSharpenPoint(face: Face, p1: Vector3, p2: Vector3) {\n  const ray = face.normalRay()\n  const theta1 = angleBetween(p1, p2, ray.origin)\n  const dist = ray.distanceToPoint(p1) * tan(PI - theta1)\n  return ray.at(dist, new Vector3())\n}\n\nexport function getSharpenPointEdge(face: Face, edge: Edge) {\n  return getSharpenPoint(face, edge.midpoint(), edge.twinFace().centroid())\n}\n\ninterface TrioOpArgs<Op, Opts = any> {\n  operation: Op\n  // pose(solid: ClassicalForme, opts: Opts): Pose\n  transformer(solid: ClassicalForme, opts: Opts, result: Classical): VertexArg[]\n  options?(entry: Classical): Opts\n}\n\ninterface TrioArgs<L, M, R> {\n  left: TrioOpArgs<L>\n  middle: Omit<TrioOpArgs<M>, \"transformer\">\n  right: TrioOpArgs<R>\n}\n\n/**\n * Create a trio of truncation OpPairs: truncate, cotruncate, and rectify.\n * Given the functions to use for operations, poses, and transformers,\n * generate the triplet of OpPairs to use.\n */\nexport function makeTruncateTrio<\n  L extends OpName,\n  M extends OpName,\n  R extends OpName\n>(\n  getPose: (forme: ClassicalForme, options: any) => Pose,\n  args: TrioArgs<L, M, R>,\n) {\n  const { left, right, middle } = args\n  function makePair(leftOp: \"left\" | \"middle\", rightOp: \"middle\" | \"right\") {\n    // Choose which side is the \"middle\" in order to short-circuit getting the intermediate\n    const middleArg =\n      leftOp === \"middle\" ? \"left\" : rightOp === \"middle\" ? \"right\" : null\n\n    return makeOpPair({\n      graph: function* () {\n        for (const entry of Classical.allWithOperation(middle.operation)) {\n          yield {\n            left: entry.withOperation(args[leftOp].operation),\n            right: entry.withOperation(args[rightOp].operation),\n            options: {\n              left: args[leftOp].options?.(entry),\n              right: args[rightOp].options?.(entry),\n            },\n          }\n        }\n      },\n      // If this is the left-right operation, then the intermediate\n      // is going to be the middle operation\n      middle:\n        middleArg ?? ((entry) => entry.left.withOperation(middle.operation)),\n      getPose: ($, solid, options) => getPose(solid, options),\n      toLeft: leftOp === \"left\" ? left.transformer : undefined,\n      toRight: rightOp === \"right\" ? right.transformer : undefined,\n    })\n  }\n\n  return {\n    truncate: makePair(\"left\", \"middle\"),\n    cotruncate: makePair(\"middle\", \"right\"),\n    rectify: makePair(\"left\", \"right\"),\n  }\n}\n","import { Facet } from \"specs\"\nimport ClassicalForme from \"math/formes/ClassicalForme\"\nimport { getTransformedVertices, Pose } from \"../operationUtils\"\nimport { getSharpenPointEdge, makeTruncateTrio } from \"./truncateHelpers\"\n\nfunction getRegularPose(\n  forme: ClassicalForme,\n  facet: Facet = forme.specs.facet(),\n): Pose {\n  return {\n    origin: forme.geom.centroid(),\n    scale: forme.facetFace(facet).distanceToCenter(),\n    orientation: forme\n      .adjacentFacetFaces(facet)\n      .map((face) => face.normal()) as any,\n  }\n}\n\n/**\n * Describes the truncation operations on a Platonic solid.\n */\nexport default makeTruncateTrio(\n  (forme, options) => getRegularPose(forme, options?.right?.facet),\n  {\n    left: {\n      operation: \"regular\",\n      transformer(forme) {\n        return getTransformedVertices(forme.minorFacetFaces(), (face) =>\n          getSharpenPointEdge(face, face.edges[0]),\n        )\n      },\n    },\n    middle: { operation: \"truncate\" },\n    right: {\n      operation: \"rectify\",\n      // The rectified version is the only thing we need to choose an option for\n      // when we move out of it\n      options: (entry) => ({ facet: entry.facet() }),\n      transformer(forme) {\n        // All edges that between two truncated faces\n        const edges = forme.geom.edges.filter((e) =>\n          e.adjacentFaces().every((f) => forme.isMainFacetFace(f)),\n        )\n        // Move each edge to its midpoint\n        return getTransformedVertices(edges, (e) => e.midpoint())\n      },\n    },\n  },\n)\n","import { sum } from \"lodash-es\"\nimport { facets } from \"specs\"\nimport { getTransformedVertices, Pose } from \"../operationUtils\"\nimport ClassicalForme from \"math/formes/ClassicalForme\"\nimport { makeTruncateTrio } from \"./truncateHelpers\"\nimport { scaleMat } from \"math/geom\"\n\nfunction avgInradius(forme: ClassicalForme) {\n  return sum(facets.map((f) => forme.inradius(f))) / facets.length\n}\n\nfunction getAmboPose(forme: ClassicalForme): Pose {\n  return {\n    origin: forme.geom.centroid(),\n    scale: avgInradius(forme),\n    orientation: forme\n      .adjacentFacetFaces(\"face\")\n      .map((face) => face.normal()) as any,\n  }\n}\n\n/**\n * A trio of operations that describe the truncation behavior on a quasi-regular polyhedron\n * (tetratetrahedron, cuboctahedron, and icosidodecahedron).\n *\n * A raw truncation on one of these doesn't yield a CRF solid. We need to do some fudging\n * in order to everything to align correctly.\n *\n * We calculate the average inradius between the face-facet faces and the vertex-facet faces\n * and use that as a scale. For both, we use a reference polyhedron and calculate the vertex\n * transformations based on them.\n */\nexport default makeTruncateTrio(getAmboPose, {\n  left: {\n    operation: \"rectify\",\n    transformer(forme, $, result) {\n      const refForme = ClassicalForme.fromSpecs(result)\n      const refInradius = avgInradius(refForme)\n      const inradius = avgInradius(forme)\n      const scale = (refForme.circumradius() / refInradius) * inradius\n      // Sharpen each of the faces to a point aligning with the vertices\n      // of the rectified solid\n      return getTransformedVertices(forme.edgeFaces(), (f) =>\n        forme.geom.centroid().clone().addScaledVector(f.normal(), scale),\n      )\n    },\n  },\n  middle: { operation: \"bevel\" },\n  right: {\n    operation: \"cantellate\",\n    transformer(forme, $, result) {\n      const refForme = ClassicalForme.fromSpecs(result)\n      const edgeFace = refForme.edgeFace()\n      const refMidradius = edgeFace.distanceToCenter()\n      const scale = avgInradius(forme) / avgInradius(refForme)\n      return getTransformedVertices(forme.edgeFaces(), (f) => {\n        const translateM = f.translateNormal(\n          refMidradius * scale - f.distanceToCenter(),\n        )\n        const scaleM = f.withCentroidOrigin(\n          scaleMat((edgeFace.radius() * scale) / f.radius()),\n        )\n        return translateM.multiply(scaleM)\n      })\n    },\n  },\n})\n","import { Composite } from \"specs\"\nimport { makeOpPair } from \"../operationPairs\"\nimport { getCentroid } from \"math/geom\"\nimport { getTransformedVertices } from \"../operationUtils\"\nimport { AugmentedClassicalForme } from \"math/formes/CompositeForme\"\nimport { find } from \"utils\"\nimport { getSharpenPoint, getSharpenPointEdge } from \"./truncateHelpers\"\n\nexport default makeOpPair<AugmentedClassicalForme>({\n  graph: function* () {\n    for (const entry of Composite.query.where(\n      (s) =>\n        s.isAugmentedClassical() &&\n        s.data.source.isClassical() &&\n        s.data.source.isRegular(),\n    )) {\n      yield {\n        left: entry,\n        right: entry.withData({\n          source: entry.sourceClassical().withOperation(\"truncate\"),\n        }),\n      }\n    }\n  },\n  middle: \"right\",\n  getPose($, forme) {\n    const { specs } = forme\n    const caps = forme.caps()\n    // Calculate the centroid *only* for the source polyhedra\n    const centroid = forme.sourceCentroid()\n    const cap = caps[0]\n    const boundary = cap.boundary()\n\n    let crossAxis\n    if (specs.isTri()) {\n      // Use the midpoin of the normals of the two other caps\n      crossAxis = getCentroid([caps[1].normal(), caps[2].normal()])\n    } else if (specs.isBi() && specs.isMeta()) {\n      // If metabiaugmented, use the normal of the other cap\n      crossAxis = caps[1].normal()\n    } else {\n      crossAxis = find(boundary.edges, (e) => forme.isMainFace(e.twinFace()))\n        .midpoint()\n        .clone()\n        .sub(boundary.centroid())\n    }\n\n    return {\n      origin: centroid,\n      scale: forme.mainFace().centroid().distanceTo(centroid),\n      orientation: [cap.normal(), crossAxis],\n    }\n  },\n  toLeft(forme) {\n    const truncatedFaces = forme.minorFaces()\n    // the inner faces of the caps\n    const cupolaFaces = forme.capTops()\n    return getTransformedVertices(\n      [...truncatedFaces, ...cupolaFaces],\n      (face) => {\n        if (cupolaFaces.some((f) => f.equals(face))) {\n          // Sharpen the cupola faces\n          const v = face.vertices[0]\n          // Find a triangular cupola face\n          const otherFace = find(\n            v.adjacentFaces(),\n            (f) => f.numSides === 3 && !f.equals(face),\n          )!\n\n          return getSharpenPoint(face, v.vec, otherFace.centroid())\n        } else {\n          const edge = find(face.edges, (e) => forme.isMainFace(e.twinFace()))\n          return getSharpenPointEdge(face, edge)\n        }\n      },\n    )\n  },\n})\n","import { oppositeFacet } from \"specs\"\nimport { combineOps } from \"../operationPairs\"\nimport Operation, { OpArgs } from \"../Operation\"\nimport { FacetOpts } from \"../operationUtils\"\nimport ClassicalForme from \"math/formes/ClassicalForme\"\nimport CompositeForme from \"math/formes/CompositeForme\"\nimport regs from \"./truncateRegular\"\nimport ambos from \"./truncateAmbo\"\nimport augTruncate from \"./truncateAugmented\"\n\nexport const truncate = new Operation(\n  \"truncate\",\n  combineOps<ClassicalForme | CompositeForme, any>([\n    regs.truncate.left,\n    ambos.truncate.left,\n    augTruncate.left,\n  ]),\n)\n\nexport const cotruncate = new Operation(\n  \"cotruncate\",\n  combineOps([regs.cotruncate.left, ambos.cotruncate.left]),\n)\n\nexport const rectify = new Operation(\n  \"rectify\",\n  combineOps([regs.rectify.left, ambos.rectify.left]),\n)\n\nconst hitOptArgs: Partial<OpArgs<FacetOpts, ClassicalForme>> = {\n  hitOption: \"facet\",\n  getHitOption(forme, hitPoint) {\n    const face = forme.geom.hitFace(hitPoint)\n    const facet = forme.getFacet(face)\n    return facet ? { facet: oppositeFacet(facet) } : {}\n  },\n\n  selectionState(face, forme, { facet }) {\n    if (forme.isFacetFace(face, oppositeFacet(facet))) return \"selected\"\n    return \"selectable\"\n  },\n}\n\nexport const sharpen = new Operation(\"sharpen\", {\n  ...combineOps<ClassicalForme | CompositeForme, Partial<FacetOpts>>([\n    regs.truncate.right,\n    ambos.truncate.right,\n    augTruncate.right,\n    regs.rectify.right,\n    ambos.rectify.right,\n  ]),\n  // TODO split up sharpening rectified and sharpening truncated\n  ...hitOptArgs,\n})\n\n// TODO the following operators are unused right now\n// and need to be integrated into the app\n\n// TODO why doesn't the typing work here?\nexport const cosharpen = new Operation(\"cosharpen\", {\n  ...combineOps<ClassicalForme, any>([\n    regs.cotruncate.right,\n    ambos.cotruncate.right,\n  ]),\n  ...hitOptArgs,\n})\n\nexport const unrectify = new Operation(\"unrectify\", {\n  ...combineOps<ClassicalForme, any>([regs.rectify.right, ambos.rectify.right]),\n  ...hitOptArgs,\n})\n","import { Classical, Facet, oppositeFacet, twists, oppositeTwist } from \"specs\"\nimport {\n  makeOpPair,\n  combineOps,\n  OpPairInput,\n  GraphOpts,\n} from \"./operationPairs\"\nimport {\n  getTransformedVertices,\n  FacetOpts,\n  TwistOpts,\n  Pose,\n} from \"./operationUtils\"\nimport Operation, { makeOperation } from \"./Operation\"\nimport ClassicalForme from \"math/formes/ClassicalForme\"\n\n/**\n * Return the expanded vertices of the polyhedron resized to the given distance-from-center\n * and rotated by the given angle\n *\n * @param faces the faces to transform\n * @param distance the normalized distance from center to put those faces\n * @param angle the angle to twist the faces by\n */\nfunction getResizedVertices(\n  forme: ClassicalForme,\n  facet: Facet,\n  result: Classical,\n) {\n  const resultForme = ClassicalForme.fromSpecs(result)\n  const angle = forme.snubAngle(facet)\n  const distance = resultForme.inradius(facet) / resultForme.geom.edgeLength()\n  const scale = forme.geom.edgeLength() * distance - forme.inradius(facet)\n  return getTransformedVertices(forme.facetFaces(facet), (f) => {\n    const rotateM = f.rotateNormal(angle)\n    const translateM = f.translateNormal(scale)\n    return f.withCentroidOrigin(rotateM.premultiply(translateM))\n  })\n}\n\nfunction getClassicalPose(forme: ClassicalForme, facet: Facet): Pose {\n  const { geom } = forme\n  return {\n    // Always centered on centroid\n    origin: geom.centroid(),\n    // Use the normal of the given face as the first axis\n    scale: geom.edgeLength(),\n    orientation: forme\n      .adjacentFacetFaces(facet)\n      .map((face) => face.normal()) as any,\n  }\n}\n\ntype ResizeArgs<L, R> = Omit<OpPairInput<ClassicalForme, L, R>, \"graph\">\n\nfunction getResizeArgs<L, R>(\n  getFacet: (opts: GraphOpts<L, R>) => Facet,\n): ResizeArgs<L, R> {\n  return {\n    middle: \"right\",\n    getPose(pos, forme, options) {\n      return getClassicalPose(forme, getFacet(options))\n    },\n    toLeft(forme, options, result) {\n      return getResizedVertices(forme, getFacet(options), result)\n    },\n  }\n}\n\nconst resizeArgs = getResizeArgs<{}, FacetOpts>((opts) => opts.right.facet)\n\n// Expansion of truncated to bevelled solids\nconst semiExpand = makeOpPair<ClassicalForme, {}, FacetOpts>({\n  ...resizeArgs,\n  graph: function* () {\n    for (const entry of Classical.allWithOperation(\"truncate\")) {\n      yield {\n        left: entry,\n        right: entry.withOperation(\"bevel\"),\n        options: { left: {}, right: { facet: entry.facet() } },\n      }\n    }\n  },\n})\n\nconst _expand = makeOpPair<ClassicalForme, {}, FacetOpts>({\n  ...resizeArgs,\n  graph: function* () {\n    for (const entry of Classical.allWithOperation(\"regular\")) {\n      yield {\n        left: entry,\n        right: entry.withOperation(\"cantellate\"),\n        options: { left: {}, right: { facet: entry.facet() } },\n      }\n    }\n  },\n})\n\nconst _snub = makeOpPair<ClassicalForme, TwistOpts, FacetOpts>({\n  ...resizeArgs,\n  graph: function* () {\n    for (const entry of Classical.allWithOperation(\"regular\")) {\n      for (const twist of twists) {\n        yield {\n          left: entry,\n          // If a vertex-solid, the chirality of the result\n          // is *opposite* of the twist option\n          right: entry.withOperation(\n            \"snub\",\n            entry.isVertex() ? oppositeTwist(twist) : twist,\n          ),\n          options: { left: { twist }, right: { facet: entry.facet() } },\n        }\n      }\n    }\n  },\n})\n\nconst _twist = makeOpPair<ClassicalForme, TwistOpts, {}>({\n  ...getResizeArgs(() => \"face\"),\n  graph: function* () {\n    for (const entry of Classical.allWithOperation(\"cantellate\")) {\n      for (const twist of twists) {\n        yield {\n          left: entry,\n          right: entry.withOperation(\"snub\", twist),\n          options: { left: { twist }, right: {} },\n        }\n      }\n    }\n  },\n})\n\nfunction getCantellatedMidradius(forme: ClassicalForme) {\n  return forme.edgeFace().distanceToCenter()\n}\n\n/**\n * Take the cantellated intermediate solid and convert it to either dual\n */\nfunction doDualTransform(forme: ClassicalForme, result: Classical) {\n  const resultForme = ClassicalForme.fromSpecs(result)\n  const resultSideLength =\n    getCantellatedMidradius(forme) / resultForme.midradius()\n  const scale = resultSideLength * resultForme.circumradius()\n  const faces = forme.facetFaces(oppositeFacet(result.facet()))\n  return getTransformedVertices(faces, (f) => {\n    return forme.geom.centroid().clone().addScaledVector(f.normal(), scale)\n  })\n}\n\nconst _dual = makeOpPair<ClassicalForme>({\n  graph: function* () {\n    for (const specs of Classical.query.where(\n      (s) => s.isRegular() && !s.isVertex(),\n    )) {\n      yield { left: specs, right: specs.withData({ facet: \"vertex\" }) }\n    }\n  },\n  middle: (entry) => entry.left.withOperation(\"cantellate\"),\n  getPose(pos, forme) {\n    const { geom } = forme\n    switch (pos) {\n      case \"left\": {\n        return {\n          ...getClassicalPose(forme, \"face\"),\n          // Everything is scaled with the same midradius\n          scale: forme.midradius(),\n        }\n      }\n      case \"right\": {\n        // for the vertex figure, pick a vertex and align it with that edge\n        const vertex = geom.getVertex()\n        const v2 = vertex.adjacentVertices()[0]\n        return {\n          origin: geom.centroid(),\n          scale: forme.midradius(),\n          orientation: [vertex.normal(), v2.normal()],\n        }\n      }\n      case \"middle\": {\n        return {\n          ...getClassicalPose(forme, \"face\"),\n          scale: getCantellatedMidradius(forme),\n        }\n      }\n    }\n  },\n  toLeft: (forme, _, result) => doDualTransform(forme, result),\n  toRight: (forme, _, result) => doDualTransform(forme, result),\n})\n\n// Exported members\n\nexport const dual = new Operation(\"dual\", combineOps([_dual.left, _dual.right]))\n\nexport const expand = new Operation(\n  \"expand\",\n  combineOps([semiExpand.left, _expand.left]),\n)\n\nexport const snub = makeOperation(\"snub\", _snub.left)\n\nexport const twist = makeOperation(\n  \"twist\",\n  combineOps([_twist.left, _twist.right]),\n)\n\n// NOTE: We are using the same operation for contracting both expanded and snub solids.\nexport const contract = makeOperation<FacetOpts, ClassicalForme>(\"contract\", {\n  ...combineOps([_expand, _snub, semiExpand].map((op) => op.right)),\n\n  hitOption: \"facet\",\n  getHitOption(forme, hitPoint) {\n    const hitFace = forme.geom.hitFace(hitPoint)\n    const facet = forme.getFacet(hitFace)\n    return facet ? { facet } : {}\n  },\n\n  selectionState(face, forme, { facet }) {\n    if (facet && forme.isFacetFace(face, facet)) return \"selected\"\n    if (forme.isAnyFacetFace(face)) return \"selectable\"\n    return undefined\n  },\n})\n","import { find } from \"utils\"\nimport { Capstone, Twist, twists, oppositeTwist } from \"specs\"\nimport { getCentroid } from \"math/geom\"\nimport CapstoneForme from \"math/formes/CapstoneForme\"\nimport { combineOps, makeOpPair } from \"./operationPairs\"\nimport { makeOperation } from \"./Operation\"\nimport { Pose, TwistOpts, getTransformedVertices } from \"./operationUtils\"\n\nconst { PI } = Math\n\nfunction getTwistMult(twist?: Twist) {\n  switch (twist) {\n    case \"left\":\n      return 1\n    case \"right\":\n      return -1\n    default:\n      return 0\n  }\n}\n\nfunction getCapstonePose(forme: CapstoneForme, twist?: Twist): Pose {\n  const [top, bottom] = forme.baseBoundaries()\n  const edge = forme.specs.isPrismatic()\n    ? top.edges[0]\n    : find(top.edges, (e) => e.face.numSides === 3)\n  const n = top.numSides\n  const angle =\n    (forme.specs.isGyroelongated() ? 1 : 0) * getTwistMult(twist) * (PI / n / 2)\n  return {\n    origin: getCentroid([top.centroid(), bottom.centroid()]),\n    scale: forme.geom.edgeLength(),\n    orientation: [\n      top.normal(),\n      edge\n        .midpoint()\n        .clone()\n        .sub(top.centroid())\n        .applyAxisAngle(top.normal(), angle),\n    ],\n  }\n}\n\nfunction getScaledPrismVertices(\n  forme: CapstoneForme,\n  scale: number,\n  twist?: Twist,\n) {\n  const vertexSets = forme.bases()\n  const angle = (getTwistMult(twist) * PI) / forme.specs.baseSides()\n\n  return getTransformedVertices(vertexSets, (set) => {\n    const rotateM = set.rotateNormal(angle / 2)\n    const translateM = set.translateNormal(scale / 2)\n    return set.withCentroidOrigin(rotateM.premultiply(translateM))\n  })\n}\n\nfunction doPrismTransform(\n  forme: CapstoneForme,\n  result: Capstone,\n  twist?: Twist,\n) {\n  const resultForme = CapstoneForme.fromSpecs(result)\n  const resultHeight =\n    (resultForme.prismaticHeight() / resultForme.geom.edgeLength()) *\n    forme.geom.edgeLength()\n  const scale = resultHeight - forme.prismaticHeight()\n  return getScaledPrismVertices(forme, scale, twist)\n}\n\ninterface PrismOpArgs {\n  // The list of *right* args\n  query(data: Capstone): boolean\n  rightElongation?: \"prism\" | \"antiprism\"\n}\n\nfunction makePrismOp({ query, rightElongation = \"antiprism\" }: PrismOpArgs) {\n  const twist = rightElongation === \"prism\" ? undefined : \"left\"\n  return (leftElongation: \"prism\" | \"none\") => {\n    return makeOpPair<CapstoneForme>({\n      graph: function* () {\n        for (const item of Capstone.query.where(\n          (s) =>\n            query(s) &&\n            !s.isPrismatic() &&\n            s.data.elongation === rightElongation,\n        )) {\n          yield {\n            left: item.withElongation(leftElongation),\n            right: item,\n          }\n        }\n      },\n      middle: \"right\",\n      getPose(side, forme) {\n        return getCapstonePose(forme, twist)\n      },\n      toLeft(forme, $, result) {\n        return doPrismTransform(forme, result, twist)\n      },\n    })\n  }\n}\n\nconst turnPrismatic = makeOpPair<CapstoneForme>({\n  // Every unelongated capstone (except fastigium) can be elongated\n  graph: function* () {\n    for (const entry of Capstone.query.where(\n      (s) => s.isPrism() && !s.isDigonal(),\n    )) {\n      yield {\n        left: entry,\n        right: entry.withElongation(\"antiprism\"),\n      }\n    }\n  },\n  middle: \"right\",\n  getPose(side, forme) {\n    return getCapstonePose(forme, \"left\")\n  },\n  toLeft: (forme, $, result) => doPrismTransform(forme, result, \"left\"),\n})\n\nconst _elongate = makePrismOp({\n  query: (s) => !s.isDigonal(),\n  rightElongation: \"prism\",\n})(\"none\")\n\nconst canGyroelongPrimary = (s: Capstone) => s.isPrimary() && !s.isTriangular()\nconst canGyroelongSecondary = (s: Capstone) => s.isSecondary() && !s.isDigonal()\n\nconst pyramidOps = makePrismOp({\n  query: (s) => canGyroelongPrimary(s),\n})\nconst gyroelongPyramid = pyramidOps(\"none\")\nconst turnPyramid = pyramidOps(\"prism\")\n\nconst cupolaOps = makePrismOp({\n  query: (s) => canGyroelongSecondary(s) && s.isMono(),\n})\n\nconst gyroelongCupola = cupolaOps(\"none\")\nconst turnCupola = cupolaOps(\"prism\")\n\nfunction makeBicupolaPrismOp(leftElongation: \"none\" | \"prism\") {\n  return makeOpPair<CapstoneForme, TwistOpts>({\n    graph: function* () {\n      for (const entry of Capstone.query.where(\n        (s) =>\n          canGyroelongSecondary(s) &&\n          s.isBi() &&\n          s.data.elongation === leftElongation,\n      )) {\n        for (const twist of twists) {\n          yield {\n            left: entry,\n            // left twisting a gyro bicupola makes it be *left* twisted\n            // but the opposite for ortho bicupolae\n            right: entry.withElongation(\n              \"antiprism\",\n              entry.isGyro() ? twist : oppositeTwist(twist),\n            ),\n            // Left and right options are opposites of each other\n            options: {\n              left: { twist },\n              right: { twist: oppositeTwist(twist) },\n            },\n          }\n        }\n      }\n    },\n    middle: \"right\",\n    getPose(side, forme, { right: { twist } }) {\n      return getCapstonePose(forme, twist)\n    },\n    toLeft: (forme, { right: { twist } }, result) => {\n      return doPrismTransform(forme, result, twist)\n    },\n  })\n}\n\nconst gyroelongBicupola = makeBicupolaPrismOp(\"none\")\nconst turnBicupola = makeBicupolaPrismOp(\"prism\")\n\n// Exported operations\n\nexport const elongate = makeOperation(\"elongate\", _elongate.left)\n\nexport const gyroelongate = makeOperation(\n  \"gyroelongate\",\n  combineOps(\n    [gyroelongPyramid, gyroelongCupola, gyroelongBicupola].map((op) => op.left),\n  ),\n)\n\nexport const shorten = makeOperation(\n  \"shorten\",\n  combineOps(\n    [_elongate, gyroelongPyramid, gyroelongCupola, gyroelongBicupola].map(\n      (op) => op.right,\n    ),\n  ),\n)\n\nexport const turn = makeOperation(\n  \"turn\",\n  combineOps<CapstoneForme, Partial<TwistOpts>>(\n    [turnPrismatic, turnPyramid, turnCupola, turnBicupola].flatMap((op) => [\n      op.left,\n      op.right,\n    ]),\n  ),\n)\n","import { repeat, find } from \"utils\"\nimport { Polyhedron, Face, FaceLike, Edge } from \"math/polyhedra\"\nimport { Capstone, CapType } from \"specs\"\nimport CapstoneForme from \"math/formes/CapstoneForme\"\nimport { deduplicateVertices, alignPolyhedron, Pose } from \"../operationUtils\"\n\nexport type CrossAxis = (edge: Edge) => boolean\n\nfunction getPose(base: FaceLike, crossAxis: CrossAxis): Pose {\n  return {\n    origin: base.centroid(),\n    scale: base.sideLength(),\n    orientation: [\n      base.normal(),\n      find(base.edges, crossAxis).midpoint().clone().sub(base.centroid()),\n    ],\n  }\n}\n\nfunction defaultCrossAxis(edge: Edge) {\n  return true\n}\n\nfunction defaultCapType(numSides: number) {\n  return numSides <= 5 ? \"pyramid\" : \"cupola\"\n}\n\nfunction getCap(type: CapType, base: number) {\n  return CapstoneForme.fromSpecs(\n    Capstone.query.where(\n      (s) =>\n        s.isMono() &&\n        s.isShortened() &&\n        s.data.base === base &&\n        type === s.capType(),\n    )[0],\n  )\n}\n\n// TODO make this a function on the cap forme\nexport function capOrientation(type: CapType): CrossAxis {\n  switch (type) {\n    case \"pyramid\":\n      return () => true\n    case \"cupola\":\n      return (e) => e.face.numSides === 4\n    case \"rotunda\":\n      return (e) => e.face.numSides === 3\n  }\n}\n\n/**\n * Add a cap to a polyhedron.\n * Base of the `augment` operation.\n */\nexport default function doAugment(\n  polyhedron: Polyhedron,\n  base: Face,\n  baseCrossAxis: CrossAxis = defaultCrossAxis,\n  capType: CapType = defaultCapType(base.numSides),\n) {\n  const numSides = base.numSides\n  const index = [\"cupola\", \"rotunda\"].includes(capType)\n    ? numSides / 2\n    : numSides\n\n  const cap = getCap(capType, index)\n\n  const [top, bottom] = cap.baseBoundaries()\n  const capPose = getPose(top, capOrientation(capType))\n  const basePose = getPose(base, baseCrossAxis)\n\n  const alignedAugmentee = alignPolyhedron(\n    cap.geom,\n    capPose,\n    basePose,\n  ).withoutFaces([bottom as Face])\n\n  const capInitial = cap.geom.withVertices(\n    repeat(base.centroid(), cap.geom.numVertices()),\n  )\n\n  const endResult = polyhedron.addPolyhedron(alignedAugmentee)\n\n  return {\n    animationData: {\n      start: polyhedron.addPolyhedron(capInitial),\n      endVertices: endResult.vertices,\n    },\n    result: deduplicateVertices(endResult.withoutFaces([base])),\n  }\n}\n","import { pickBy } from \"lodash-es\"\nimport { Face, Cap } from \"math/polyhedra\"\nimport {\n  Capstone,\n  Composite,\n  Elementary,\n  CapType,\n  Align,\n  Gyration,\n  gyrations,\n} from \"specs\"\nimport CompositeForme from \"math/formes/CompositeForme\"\nimport { OpArgs } from \"../Operation\"\nimport PolyhedronForme from \"math/formes/PolyhedronForme\"\nimport CapstoneForme from \"math/formes/CapstoneForme\"\nimport { GraphGenerator, OpInput, toDirected } from \"../operationPairs\"\nimport removeCap from \"./removeCap\"\nimport addCap, { CrossAxis } from \"./addCap\"\n\nfunction canAugment(forme: PolyhedronForme, face: Face) {\n  if (forme instanceof CapstoneForme) {\n    return forme.baseFaces().some((base) => base.equals(face))\n  } else if (forme instanceof CompositeForme) {\n    return forme.canAugment(face)\n  } else {\n    // Elementary solid\n    return face.numSides === 4\n  }\n}\n\nfunction hasRotunda(info: CutPasteSpecs) {\n  if (info.isCapstone()) {\n    return info.isSecondary() && info.isPentagonal()\n  }\n  return false\n}\n\nfunction getUsingOpts(info: CutPasteSpecs): CapType[] | null {\n  if (hasRotunda(info)) {\n    return [\"cupola\", \"rotunda\"]\n  }\n  return null\n}\n\nfunction hasGyrateOpts(info: CutPasteSpecs) {\n  if (info.isCapstone()) {\n    if (!info.isMono()) return false\n    // Gyroelongated capstones are always gyro\n    if (info.isGyroelongated()) return false\n    // Cupolae and rotundae (that are not the gyrobifastigium) always have gyrate opts\n    if (!info.isDigonal() && info.isSecondary()) return true\n    return false\n  }\n  if (info.isComposite()) {\n    return info.isGyrateSolid()\n  }\n  return false\n}\n\nexport type CutPasteSpecs = Capstone | Composite | Elementary\n\nexport interface CapOptions {\n  cap: Cap\n}\n\ninterface DimGraphOpts {\n  using?: CapType\n  align?: Align\n  gyrate?: Gyration\n}\n\ninterface AugGraphOpts extends DimGraphOpts {\n  faceType?: number\n}\n\ninterface AugOptions {\n  face: Face\n  gyrate?: Gyration\n  using?: CapType\n}\n\ntype AugDimGraphGenerator<S> = GraphGenerator<S, AugGraphOpts, DimGraphOpts>\n\ninterface CutPastePairInput<F extends PolyhedronForme> {\n  /** The bidirectional graph representing solids that can be augmented or diminished. */\n  graph(): AugDimGraphGenerator<F[\"specs\"]>\n  /** How to transform the arguments to graph options for diminish */\n  toDimGraphOpts?(forme: F, options: CapOptions): DimGraphOpts\n  /** How to transform the arguments to graph options for augment */\n  toAugGraphOpts?(forme: F, options: AugOptions): AugGraphOpts\n  /** Get the axis of the polyhedron base when augmenting */\n  baseAxis?(forme: F, options: AugOptions): CrossAxis | undefined\n}\n\ninterface CutPastePair<F extends PolyhedronForme> {\n  augment: OpInput<AugOptions, F, AugGraphOpts>\n  diminish: OpInput<CapOptions, F, DimGraphOpts>\n}\n\nfunction defaultGraphOpts() {\n  return {}\n}\n\n/**\n * Create a pair of augment/diminish operations.\n */\nexport function makeCutPastePair<F extends PolyhedronForme>(\n  input: CutPastePairInput<F>,\n): CutPastePair<F> {\n  return {\n    augment: {\n      graph: toDirected(\"left\", input.graph),\n      toGraphOpts: input.toAugGraphOpts ?? defaultGraphOpts,\n      apply(forme, options) {\n        const { using, face } = options\n        const baseAxis = input.baseAxis?.(forme, options)\n        return addCap(forme.geom, face, baseAxis, using)\n      },\n    },\n    diminish: {\n      graph: toDirected(\"right\", input.graph),\n      toGraphOpts: input.toDimGraphOpts ?? defaultGraphOpts,\n      apply: ({ geom }, { cap }) => removeCap(geom, cap),\n    },\n  }\n}\n\nfunction getCaps(forme: PolyhedronForme) {\n  if (forme instanceof CapstoneForme) {\n    return forme.baseCaps()\n  } else {\n    // FIXME this doesn't return the right thing for composite\n    return forme.geom.caps()\n  }\n}\n\ntype CapOptionArgs = Partial<OpArgs<CapOptions, PolyhedronForme, DimGraphOpts>>\ntype AugOptionArgs = Partial<\n  OpArgs<AugOptions, PolyhedronForme<CutPasteSpecs>, AugGraphOpts>\n>\n\nexport const capOptionArgs: CapOptionArgs = {\n  hasOptions() {\n    return true\n  },\n\n  allOptions(forme) {\n    return {\n      cap: getCaps(forme),\n    }\n  },\n\n  hitOption: \"cap\",\n  getHitOption({ geom }, hitPnt) {\n    // FIXME only allow the right caps\n    const cap = Cap.find(geom, hitPnt)\n    return cap ? { cap } : {}\n  },\n\n  selectionState(face, forme, { cap }) {\n    const allCapFaces = getCaps(forme).flatMap((cap) => cap.faces())\n    if (cap instanceof Cap && face.inSet(cap.faces())) return \"selected\"\n    if (face.inSet(allCapFaces)) return \"selectable\"\n    return undefined\n  },\n}\n\n// TODO putting this here is a little awkward\nexport const augOptionArgs: AugOptionArgs = {\n  hasOptions() {\n    return true\n  },\n\n  hitOption: \"face\",\n  getHitOption(forme, hitPnt, options) {\n    if (!options) return {}\n    const face = forme.geom.hitFace(hitPnt)\n    return canAugment(forme, face) ? { face } : {}\n  },\n\n  selectionState(f, forme, { face }) {\n    if (face && f.equals(face)) return \"selected\"\n    if (canAugment(forme, f)) return \"selectable\"\n    return undefined\n  },\n\n  allOptions(forme) {\n    const { specs, geom } = forme\n    return {\n      gyrate: hasGyrateOpts(specs) ? gyrations : [undefined],\n      using: getUsingOpts(specs) ?? [undefined],\n      face: geom.faces.filter((face) => canAugment(forme, face)),\n    }\n  },\n\n  defaultOptions(info) {\n    const usingOpts = getUsingOpts(info) ?? []\n    return pickBy({\n      gyrate: hasGyrateOpts(info) && \"gyro\",\n      using: usingOpts.length > 1 && usingOpts[0],\n    })\n  },\n}\n","import { range } from \"lodash-es\"\nimport { mapObject } from \"utils\"\nimport { Polyhedron, Cap } from \"math/polyhedra\"\nimport {\n  getTransformedVertices,\n  removeExtraneousVertices,\n} from \"../operationUtils\"\n\n/**\n * Removes a cap from a polyhedron.\n * Base of the `diminish` operation.\n */\nexport default function removeCap(polyhedron: Polyhedron, cap: Cap) {\n  const boundary = cap.boundary()\n  const oldToNew = mapObject(boundary.vertices, (vertex, i) => [\n    vertex.index,\n    i,\n  ])\n  const mockPolyhedron = polyhedron.withChanges((s) =>\n    s\n      .addVertices(boundary.vertices)\n      .mapFaces((face) => {\n        if (face.inSet(cap.faces())) {\n          return face\n        }\n        return face.vertices.map((v) => {\n          return v.inSet(boundary.vertices)\n            ? polyhedron.numVertices() + oldToNew[v.index]\n            : v.index\n        })\n      })\n      .addFaces([\n        range(\n          polyhedron.numVertices(),\n          polyhedron.numVertices() + boundary.numSides,\n        ),\n      ]),\n  )\n\n  const endVertices = getTransformedVertices(\n    [cap],\n    () => boundary.centroid(),\n    mockPolyhedron.vertices,\n  )\n\n  return {\n    animationData: {\n      start: mockPolyhedron,\n      endVertices,\n    },\n    result: removeExtraneousVertices(\n      polyhedron.withChanges((s) =>\n        s.withoutFaces(cap.faces()).addFaces([cap.boundary().vertices]),\n      ),\n    ),\n  }\n}\n","import { Capstone } from \"specs\"\nimport CapstoneForme from \"math/formes/CapstoneForme\"\nimport { makeCutPastePair } from \"./cutPasteUtils\"\nimport { capOrientation } from \"./addCap\"\n\nexport default makeCutPastePair<CapstoneForme>({\n  graph: function* () {\n    // Take every capstone solid that has at least one cap,\n    // and ignore pure capstones\n    for (const cap of Capstone.query.where(\n      (s) => !s.isSnub() && !s.isPrismatic() && (s.isBi() || !s.isShortened()),\n    )) {\n      // Some capstones can be modified with rotunda\n      for (const capType of cap.capTypes()) {\n        yield {\n          left: cap.remove(capType),\n          right: cap,\n          options: {\n            left: { gyrate: cap.data.gyrate, using: capType },\n            right: { using: capType },\n          },\n        }\n      }\n    }\n  },\n  toAugGraphOpts($, { face, ...opts }) {\n    return opts\n  },\n  toDimGraphOpts(forme, { cap }) {\n    if (!forme.specs.isCupolaRotunda()) return {}\n    // Determine the cap type for cupolarotundae\n    return { using: cap.type }\n  },\n  baseAxis(forme, { gyrate }) {\n    const { specs } = forme\n    // TODO gyroelongated bi solids need to pick an orientation for the right twist\n    if (specs.isPrismatic() || specs.isPrimary() || specs.isGyroelongated()) {\n      return\n    }\n    // FIXME this might fail with the digonal cupola?\n    const orientationFn = capOrientation(forme.baseCaps()[0].type)\n    return (edge) => {\n      // Determine the cupola face to check\n      edge = edge.twin()\n      // If elongated, pick the edge belonging to the opposite face\n      if (!specs.isShortened()) edge = edge.next().next().twin()\n      // Line the square faces if ortho, but not if gyro\n      return gyrate === \"ortho\" ? orientationFn(edge) : !orientationFn(edge)\n    }\n  },\n})\n","import { Composite } from \"specs\"\nimport CompositeForme from \"math/formes/CompositeForme\"\nimport { makeCutPastePair } from \"./cutPasteUtils\"\n\nexport default makeCutPastePair<CompositeForme>({\n  graph: function* () {\n    // Take all augmented solids with at least one augmentation\n    // and pair it with its diminishing\n    for (const solid of Composite.query.where(\n      (s) => s.isAugmentedSolid() && s.isAugmented(),\n    )) {\n      yield {\n        left: solid.diminish(),\n        right: solid,\n        options: {\n          left: { align: solid.data.align },\n          right: {},\n        },\n      }\n    }\n  },\n  toAugGraphOpts(forme, { face }) {\n    return { align: forme.alignment(face) }\n  },\n  baseAxis({ specs }) {\n    const { source } = specs.data\n    // Make sure that augmented truncated polyhedra align\n    // the square cupola face to a triangular face\n    if (source.isClassical() && source.isTruncated()) {\n      return (edge) => edge.twinFace().numSides === 3\n    }\n  },\n})\n","import { Composite } from \"specs\"\nimport { DiminishedSolidForme } from \"math/formes/CompositeForme\"\nimport { makeCutPastePair } from \"./cutPasteUtils\"\n\nexport default makeCutPastePair<DiminishedSolidForme>({\n  graph: function* () {\n    // Pick every diminished icosahedron except the tridiminished augmented\n    for (const solid of Composite.query.where(\n      (s) => s.isDiminishedSolid() && s.isDiminished() && !s.isAugmented(),\n    )) {\n      const options = solid.isTri() ? [3, 5] : [5]\n      for (const faceType of options) {\n        yield {\n          left: solid,\n          right: solid.augmentDiminished(faceType === 3),\n          options: {\n            left: { faceType },\n            right: { align: solid.data.align },\n          },\n        }\n      }\n    }\n  },\n  toAugGraphOpts(forme, { face }) {\n    return { faceType: face.numSides }\n  },\n  toDimGraphOpts(forme, { cap }) {\n    return { align: forme.alignment(cap) }\n  },\n})\n","import { Composite, gyrations } from \"specs\"\nimport { GyrateSolidForme } from \"math/formes/CompositeForme\"\nimport { makeCutPastePair } from \"./cutPasteUtils\"\n\nexport default makeCutPastePair<GyrateSolidForme>({\n  graph: function* () {\n    for (const solid of Composite.query.where(\n      (s) => s.isGyrateSolid() && s.isDiminished(),\n    )) {\n      // Each solid can be gyro-augmented or ortho-augmented\n      for (const gyrate of gyrations) {\n        yield {\n          left: solid,\n          right: solid.augmentGyrate(gyrate),\n          options: {\n            left: { gyrate },\n            right: { gyrate, align: solid.data.align },\n          },\n        }\n      }\n    }\n  },\n  toAugGraphOpts($, { face, ...opts }) {\n    return { gyrate: opts.gyrate }\n  },\n  toDimGraphOpts(forme, { cap }) {\n    if (forme.isGyrate(cap)) {\n      return { gyrate: \"ortho\" }\n    } else {\n      return { gyrate: \"gyro\", align: forme.alignment(cap) }\n    }\n  },\n  baseAxis($, { gyrate }) {\n    // If ortho, line the square face of the cupola with a square face here\n    return (edge) => edge.twinFace().numSides === (gyrate === \"ortho\" ? 4 : 5)\n  },\n})\n","import { makeCutPastePair } from \"./cutPasteUtils\"\nimport { Elementary } from \"specs\"\n\nexport default makeCutPastePair({\n  graph: function* () {\n    yield {\n      left: Elementary.query.withName(\"sphenocorona\"),\n      right: Elementary.query.withName(\"augmented sphenocorona\"),\n    }\n  },\n})\n","import { Polyhedron } from \"math/polyhedra\"\nimport { mapObject } from \"utils\"\nimport { Capstone, Composite } from \"specs\"\nimport { CapOptions, capOptionArgs } from \"./cutPasteUtils\"\nimport { getTransformedVertices } from \"../operationUtils\"\nimport { makeOperation } from \"../Operation\"\nimport CapstoneForme from \"math/formes/CapstoneForme\"\nimport CompositeForme, { GyrateSolidForme } from \"math/formes/CompositeForme\"\nimport {\n  GraphGenerator,\n  toDirected,\n  combineOps,\n  OpInput,\n} from \"../operationPairs\"\nimport PolyhedronForme from \"math/formes/PolyhedronForme\"\n\nconst TAU = 2 * Math.PI\n\nfunction applyGyrate(polyhedron: Polyhedron, { cap }: CapOptions) {\n  // get adjacent faces\n  const boundary = cap.boundary()\n  // rotate the cupola/rotunda top\n  const theta = TAU / boundary.numSides\n  const oldToNew = mapObject(boundary.vertices, (vertex, i) => [\n    vertex.index,\n    i,\n  ])\n\n  const mockPolyhedron = polyhedron.withChanges((solid) =>\n    solid.addVertices(boundary.vertices).mapFaces((face) => {\n      if (face.inSet(cap.faces())) {\n        return face\n      }\n      return face.vertices.map((v) => {\n        return v.inSet(boundary.vertices)\n          ? polyhedron.numVertices() + oldToNew[v.index]\n          : v.index\n      })\n    }),\n  )\n\n  const endVertices = getTransformedVertices(\n    [cap],\n    (cap) => cap.withCentroidOrigin(cap.rotateNormal(theta)),\n    mockPolyhedron.vertices,\n  )\n\n  // TODO the animation makes the cupola shrink and expand.\n  // Make it not do that.\n  return {\n    animationData: {\n      start: mockPolyhedron,\n      endVertices,\n    },\n  }\n}\n\nexport interface GraphOpts {\n  align?: \"meta\" | \"para\"\n  direction?: \"forward\" | \"back\"\n}\n\ntype GyrateGraphGenerator<S> = GraphGenerator<S, GraphOpts, GraphOpts>\n\ninterface GyrateArgs<F extends PolyhedronForme> {\n  graph(): GyrateGraphGenerator<F[\"specs\"]>\n  toGraphOpts(forme: F, options: CapOptions): GraphOpts\n}\n\nfunction makeGyrateOp<F extends PolyhedronForme>({\n  graph,\n  toGraphOpts,\n}: GyrateArgs<F>): GyrateOpArgs<F> {\n  return {\n    graph: function* () {\n      yield* toDirected(\"left\", graph)()\n      yield* toDirected(\"right\", graph)()\n    },\n    toGraphOpts,\n    apply({ geom }, options) {\n      return applyGyrate(geom, options)\n    },\n  }\n}\n\ntype GyrateOpArgs<F extends PolyhedronForme> = OpInput<CapOptions, F, GraphOpts>\n\nconst gyrateCapstone = makeGyrateOp<CapstoneForme>({\n  graph: function* () {\n    for (const cap of Capstone.query.where(\n      (s) => (s.hasGyrate() && s.isOrtho() && !s.isDigonal()) || s.isChiral(),\n    )) {\n      yield { left: cap, right: cap.gyrate() }\n    }\n  },\n  toGraphOpts() {\n    return {}\n  },\n})\n\nconst gyrateComposite = makeGyrateOp<GyrateSolidForme>({\n  graph: function* () {\n    for (const solid of Composite.query.where(\n      (s) => s.isGyrateSolid() && s.isGyrate(),\n    )) {\n      yield {\n        left: solid.ungyrate(),\n        right: solid,\n        options: {\n          left: { direction: \"forward\", align: solid.data.align },\n          right: { direction: \"back\" },\n        },\n      }\n    }\n  },\n  toGraphOpts(forme, { cap }) {\n    if (forme.isGyrate(cap)) {\n      return { direction: \"back\" }\n    } else {\n      return { direction: \"forward\", align: forme.alignment(cap) }\n    }\n  },\n})\n\nexport const gyrate = makeOperation(\"gyrate\", {\n  ...combineOps<CapstoneForme | CompositeForme, CapOptions, GraphOpts>([\n    gyrateCapstone,\n    gyrateComposite,\n  ]),\n  ...capOptionArgs,\n})\n","import capstone from \"./cutPasteCapstone\"\nimport augmented from \"./cutPasteAugmented\"\nimport diminished from \"./cutPasteDiminished\"\nimport gyrated from \"./cutPasteGyrate\"\nimport elementary from \"./cutPasteElementary\"\nimport { capOptionArgs, augOptionArgs } from \"./cutPasteUtils\"\nimport { combineOps } from \"../operationPairs\"\nimport { makeOperation } from \"../Operation\"\n\nconst ops = [capstone, augmented, diminished, gyrated, elementary]\n\nexport const augment = makeOperation(\"augment\", {\n  ...combineOps(ops.map((op) => op.augment)),\n  ...augOptionArgs,\n})\n\nexport const diminish = makeOperation(\"diminish\", {\n  ...combineOps(ops.map((op) => op.diminish)),\n  ...capOptionArgs,\n})\n\nexport { gyrate } from \"./gyrate\"\n","import {\n  truncate,\n  // cotruncate,\n  sharpen,\n  // cosharpen,\n  rectify,\n  // unrectify,\n} from \"./truncateOps\"\nimport { dual, expand, snub, contract, twist } from \"./resizeOps\"\nimport { elongate, gyroelongate, shorten, turn } from \"./prismOps\"\nimport { augment, diminish, gyrate } from \"./cutPasteOps\"\n\nexport type { default as Operation, AnimationData } from \"./Operation\"\n\nexport const operations = {\n  dual,\n  truncate,\n  // cotruncate,\n  sharpen,\n  // cosharpen,\n  rectify,\n  // unrectify,\n  expand,\n  snub,\n  contract,\n  twist,\n  elongate,\n  gyroelongate,\n  shorten,\n  turn,\n  augment,\n  diminish,\n  gyrate,\n}\n\nexport type OpName = keyof typeof operations\n","import React from \"react\"\nimport { range } from \"lodash-es\"\n\nconst { PI, sin, cos } = Math\nconst TAU = 2 * PI\n\nexport type Point2D = [number, number]\n\ninterface PointsProps {\n  points: Point2D[]\n  [prop: string]: any\n}\n\nfunction joinPoints(points: Point2D[]) {\n  return points.map((point) => point.join(\",\")).join(\" \")\n}\n\n// Irregular polygon\nexport function PolyShape({ points, ...rest }: PointsProps) {\n  return <polygon {...rest} points={joinPoints(points)} />\n}\n\nexport function PolyLine({ points, ...rest }: PointsProps) {\n  return <polyline {...rest} points={joinPoints(points)} />\n}\n\ninterface PolygonProps {\n  n?: number\n  r?: number\n  cx?: number\n  cy?: number\n  a?: number\n  [prop: string]: any\n}\n\nexport function polygonPoints({\n  n = 3,\n  r = 1,\n  cx = 0,\n  cy = 0,\n  a = 0,\n}: PolygonProps) {\n  return range(n).map<Point2D>((i) => [\n    cx + r * cos(TAU * (a / 360 + i / n)),\n    cy + r * sin(TAU * (a / 360 + i / n)),\n  ])\n}\n\n// Regular polygon\nexport function Polygon({\n  n = 3,\n  r = 1,\n  cx = 0,\n  cy = 0,\n  a = 0,\n  ...rest\n}: PolygonProps) {\n  const points = polygonPoints({ n, r, cx, cy, a })\n  return <PolyShape {...rest} points={points} />\n}\n","import { range } from \"lodash-es\"\n\nimport React, { memo, ComponentType } from \"react\"\nimport { StyleSheet, css } from \"aphrodite/no-important\"\n\nimport { OpName } from \"math/operations\"\nimport { Polygon, PolyLine } from \"components/svg\"\nimport { square } from \"styles/common\"\nimport { scales } from \"styles\"\nconst { sqrt } = Math\n\ntype SheetDefinition = { [key: string]: {} }\n\ntype KeyType = string | false\n\n// TODO usually we would do `useStyle`, but I can't figure out\n// how to make it look reasonable. Plus, I'm thinking of redoing these anyway.\nfunction makeStyles(inputStyles: SheetDefinition) {\n  const styles = StyleSheet.create(inputStyles)\n\n  return (...keys: KeyType[]) => {\n    return css(...keys.map((key) => !!key && styles[key]))\n  }\n}\n\nconst color = \"DimGray\"\nconst styles = makeStyles({\n  operationIcon: square(scales.size[3]),\n\n  invariant: {\n    fill: color,\n    stroke: color,\n    strokeWidth: 5,\n    strokeLinejoin: \"round\",\n  },\n\n  subtracted: {\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: 5,\n    strokeDasharray: 10,\n  },\n\n  added: {\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: 5,\n    strokeLinejoin: \"round\",\n  },\n\n  changed: {\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: 5,\n  },\n})\n\ninterface TruncateIconProps {\n  styled: string\n  innerSides?: number\n  innerScale?: number\n  innerAngle?: number\n}\n\nfunction TruncateIcon({\n  styled,\n  innerSides = 6,\n  innerScale = 1 / sqrt(3),\n  innerAngle = 0,\n}: TruncateIconProps) {\n  const center = { cx: 100, cy: 120 }\n  const r = 100\n  return (\n    <>\n      <Polygon className={styles(styled)} n={3} r={r} a={-90} {...center} />\n      <Polygon\n        className={styles(\"invariant\")}\n        n={innerSides}\n        r={r * innerScale}\n        a={innerAngle}\n        {...center}\n      />\n    </>\n  )\n}\n\nfunction DualIcon() {\n  const center = { cx: 100, cy: 100 }\n  const r = 75\n  return (\n    <>\n      <Polygon\n        className={styles(\"subtracted\")}\n        n={3}\n        r={r}\n        a={-90}\n        {...center}\n      />\n      <Polygon className={styles(\"added\")} n={3} r={r} a={90} {...center} />\n      <Polygon\n        className={styles(\"invariant\")}\n        n={6}\n        r={r / sqrt(3)}\n        a={0}\n        {...center}\n      />\n    </>\n  )\n}\n\ninterface ExpandIconRenderProps {\n  cx: number\n  cy: number\n  r: number\n  ap: number\n  r1: number\n  ap1: number\n}\n\ninterface ExpandIconProps {\n  styled: string\n  render?: ComponentType<ExpandIconRenderProps>\n  hollow?: boolean\n  innerStyle?: string\n  innerAngle?: number\n}\n\nfunction BaseExpandIcon({\n  styled,\n  render: Renderer = () => null,\n  hollow = false,\n  innerAngle = 0,\n}: ExpandIconProps) {\n  const [cx, cy] = [100, 100]\n  const r = 80\n  const ap = (sqrt(3) * r) / 2\n  const r1 = r / sqrt(3)\n  const ap1 = r1 / 2\n  return (\n    <>\n      <Polygon className={styles(styled)} n={6} r={r} a={0} cx={cx} cy={cy} />\n      <Polygon\n        className={styles(hollow ? styled : \"invariant\")}\n        n={3}\n        r={r1}\n        a={innerAngle}\n        cx={cx}\n        cy={cy}\n      />\n      <Renderer {...{ cx, cy, r, ap, r1, ap1 }} />\n    </>\n  )\n}\n\nfunction ExpandIcon({\n  styled,\n  render: Renderer = () => null,\n  innerStyle = styled,\n  hollow = false,\n}: ExpandIconProps) {\n  return (\n    <BaseExpandIcon\n      styled={styled}\n      innerAngle={-90}\n      hollow={hollow}\n      render={({ cx, cy, r, ap, r1, ap1 }) => (\n        <>\n          {range(3).map((i) => (\n            <PolyLine\n              key={i}\n              className={styles(innerStyle)}\n              transform={`rotate(${i * 120} ${cx} ${cy})`}\n              points={[\n                [cx - r / 2, cy - ap],\n                [cx, cy - r1],\n                [cx + r / 2, cy - ap],\n              ]}\n            />\n          ))}\n          <Renderer {...{ cx, cy, r, ap, r1, ap1 }} />\n        </>\n      )}\n    />\n  )\n}\n\ninterface ElongateIconRenderProps {\n  cx: number\n  cy: number\n  r: number\n  ap: number\n}\ninterface ElongateIconProps {\n  styled: string\n  render?: ComponentType<ElongateIconRenderProps>\n}\nfunction ElongateIcon({ styled, render: Renderer }: ElongateIconProps) {\n  // TODO consolidate with expand\n  const [cx, cy] = [100, 100]\n  const r = 80\n  const ap = (sqrt(3) * r) / 2\n  return (\n    <>\n      <Polygon className={styles(styled)} n={6} r={r} a={90} cx={cx} cy={cy} />\n      <PolyLine\n        className={styles(\"invariant\")}\n        points={[\n          [cx - ap, cy - r / 2],\n          [cx, cy - r],\n          [cx + ap, cy - r / 2],\n        ]}\n      />\n      <PolyLine\n        className={styles(\"invariant\")}\n        points={[\n          [cx - ap, cy + r / 2],\n          [cx, cy + r],\n          [cx + ap, cy + r / 2],\n        ]}\n      />\n      {Renderer ? (\n        <Renderer {...{ cx, cy, r, ap }} />\n      ) : (\n        <rect\n          className={styles(styled)}\n          x={cx - r / 2}\n          y={cy - r / 2 - 5}\n          width={r}\n          height={r + 10}\n        />\n      )}\n    </>\n  )\n}\n\nfunction AugmentIcon({ styled }: { styled: string }) {\n  const [cx, cy] = [100, 100]\n  const r = 80\n  const ap = (sqrt(3) * r) / 2\n  return (\n    <>\n      <Polygon className={styles(styled)} n={6} r={r} a={90} cx={cx} cy={cy} />\n      <PolyLine\n        className={styles(\"invariant\")}\n        points={[\n          [cx - ap, cy - r / 2],\n          [cx - ap, cy + r / 2],\n          [cx, cy + r],\n          [cx + ap, cy + r / 2],\n          [cx + ap, cy - r / 2],\n        ]}\n      />\n    </>\n  )\n}\n\nfunction drawIcon(name: OpName) {\n  switch (name) {\n    case \"truncate\":\n      return <TruncateIcon styled=\"subtracted\" />\n    case \"rectify\":\n      return (\n        <TruncateIcon\n          styled=\"subtracted\"\n          innerSides={3}\n          innerScale={1 / 2}\n          innerAngle={90}\n        />\n      )\n    case \"sharpen\":\n      return <TruncateIcon styled=\"added\" />\n    case \"dual\":\n      return <DualIcon />\n    case \"expand\": {\n      return <ExpandIcon styled=\"added\" />\n    }\n    case \"snub\": {\n      return (\n        <BaseExpandIcon\n          styled=\"added\"\n          hollow={false}\n          innerAngle={0}\n          render={({ cx, cy, r, ap, ap1 }) => (\n            <>\n              {range(3).map((i) => (\n                <PolyLine\n                  key={i}\n                  className={styles(\"added\")}\n                  transform={`rotate(${i * 120} ${cx} ${cy})`}\n                  points={[\n                    [cx - ap1, cy - r / 2],\n                    [cx - r, cy],\n                    [cx - ap1, cy + r / 2],\n                    [cx - r / 2, cy + ap],\n                  ]}\n                />\n              ))}\n            </>\n          )}\n        />\n      )\n    }\n    case \"contract\": {\n      return <ExpandIcon styled=\"subtracted\" />\n    }\n    case \"twist\": {\n      return (\n        <ExpandIcon\n          styled=\"changed\"\n          innerStyle=\"invariant\"\n          render={({ cx, cy, r, ap, ap1 }) => (\n            <>\n              {range(3).map((i) => (\n                <PolyLine\n                  key={i}\n                  className={styles(\"changed\")}\n                  transform={`rotate(${i * 120} ${cx} ${cy})`}\n                  points={[\n                    [cx - r / 2, cy + ap1],\n                    [cx + r / 2, cy + ap],\n                  ]}\n                />\n              ))}\n            </>\n          )}\n        />\n      )\n    }\n\n    case \"elongate\":\n      return <ElongateIcon styled=\"added\" />\n\n    case \"gyroelongate\":\n      return (\n        <ElongateIcon\n          styled=\"added\"\n          render={({ cx, cy, r, ap }) => (\n            <PolyLine\n              className={styles(\"added\")}\n              points={[\n                [cx - ap, cy - r / 2],\n                [cx - r / 2, cy + r / 2],\n                [cx, cy - r / 2],\n                [cx + r / 2, cy + r / 2],\n                [cx + ap, cy - r / 2],\n              ]}\n            />\n          )}\n        />\n      )\n\n    case \"shorten\":\n      return <ElongateIcon styled=\"subtracted\" />\n\n    case \"turn\":\n      return (\n        <ElongateIcon\n          styled=\"added\"\n          render={({ cx, cy, r, ap }) => (\n            <PolyLine\n              className={styles(\"added\")}\n              points={[\n                [cx - ap, cy - r / 2],\n                [cx - r / 2, cy + r / 2],\n                [cx - r / 2, cy - r / 2],\n                [cx + r / 2, cy + r / 2],\n                [cx + r / 2, cy - r / 2],\n                [cx + ap, cy + r / 2],\n              ]}\n            />\n          )}\n        />\n      )\n    case \"augment\":\n      return <AugmentIcon styled=\"added\" />\n    case \"diminish\":\n      return <AugmentIcon styled=\"subtracted\" />\n    case \"gyrate\":\n      // TODO simplify the ExpandIcon hierarchy\n      return (\n        <>\n          <ExpandIcon styled=\"subtracted\" hollow />\n          <g transform=\"rotate(180 100 100)\">\n            <ExpandIcon styled=\"added\" hollow />\n          </g>\n        </>\n      )\n    default:\n      throw new Error(`Unknown operation: ${name}`)\n  }\n}\n\ninterface Props {\n  name: OpName\n}\n\nexport default memo(function OperationIcon({ name }: Props) {\n  return (\n    <svg viewBox=\"0 0 200 200\" className={styles(\"operationIcon\")}>\n      {drawIcon(name)}\n    </svg>\n  )\n})\n","import { uniq } from \"lodash-es\"\n\nimport React, { memo } from \"react\"\n\nimport { useStyle, scales } from \"styles\"\nimport { media, fonts } from \"styles\"\nimport { hover, scroll, square, flexColumn, flexRow } from \"styles/common\"\nimport { operations, OpName } from \"math/operations\"\nimport {\n  useApplyOperation,\n  OperationCtx,\n  TransitionCtx,\n  PolyhedronCtx,\n} from \"components/ViewerPage/context\"\nimport OperationIcon from \"./OperationIcon\"\n\nconst opLayout: OpName[][] = [\n  [\"truncate\", \"rectify\", \"sharpen\", \"dual\"],\n  [\"expand\", \"snub\", \"contract\", \"twist\"],\n  [\"elongate\", \"gyroelongate\", \"shorten\", \"turn\"],\n  [\"augment\", \"augment\", \"diminish\", \"gyrate\"],\n]\n\nconst opList = uniq(opLayout.flat())\n\ninterface Props {\n  name: OpName\n  disabled: boolean\n}\nconst OpButton = memo(function ({ name, disabled }: Props) {\n  const polyhedron = PolyhedronCtx.useState()\n  const { operation: currentOp } = OperationCtx.useState()\n  const { setOperation, unsetOperation } = OperationCtx.useActions()\n  const applyOperation = useApplyOperation()\n  const operation = operations[name]\n  const isCurrent = !!currentOp && name === currentOp.name\n\n  const css = useStyle(\n    {\n      ...flexColumn(\"center\", \"center\"),\n      ...hover,\n      ...square(\"5rem\"),\n      border: isCurrent ? \"2px DarkSlateGray solid\" : \"1px LightGray solid\",\n      fontFamily: fonts.verdana,\n      fontSize: scales.font[7],\n      color: \"DimGray\",\n      backgroundColor: \"white\",\n\n      \":disabled\": { opacity: 0.3 },\n      // add spacing since we're displayed in a row\n      // TODO can we do this in the parent styling?\n      [media.mobile]: {\n        \":not(:last-child)\": { marginRight: scales.spacing[2] },\n      },\n    },\n    [isCurrent],\n  )\n\n  const selectOperation = () => {\n    if (isCurrent) {\n      return unsetOperation()\n    }\n\n    if (!operation.hasOptions(polyhedron)) {\n      applyOperation(operation)\n    } else {\n      setOperation(operation, polyhedron)\n    }\n  }\n  return (\n    <button\n      {...css()}\n      style={{ gridArea: name }}\n      onClick={selectOperation}\n      disabled={!operation.canApplyTo(polyhedron) || disabled}\n    >\n      <OperationIcon name={name} />\n      {name}\n    </button>\n  )\n})\n\nconst templateString = opLayout.map((line) => `\"${line.join(\" \")}\"`).join(\"\\n\")\n\nexport default function OpGrid() {\n  const { unsetOperation } = OperationCtx.useActions()\n  const { isTransitioning } = TransitionCtx.useState()\n\n  React.useEffect(() => {\n    return () => {\n      unsetOperation()\n    }\n  }, [unsetOperation])\n  const css = useStyle({\n    [media.notMobile]: {\n      display: \"grid\",\n      justifyContent: \"space-between\",\n      gridColumnGap: scales.spacing[1],\n      gridRowGap: scales.spacing[2],\n      gridTemplateAreas: templateString,\n    },\n    [media.mobile]: {\n      ...flexRow(),\n      ...scroll(\"x\"),\n      width: \"100%\",\n    },\n  })\n  return (\n    <div {...css()}>\n      {opList.map((name) => (\n        <OpButton key={name} name={name} disabled={isTransitioning} />\n      ))}\n    </div>\n  )\n}\n","import React, { ButtonHTMLAttributes } from \"react\"\nimport { useStyle, scales } from \"styles\"\n\nimport { TransitionCtx, PolyhedronCtx } from \"components/ViewerPage/context\"\n\nimport createForme from \"math/formes/createForme\"\nimport { Polyhedron } from \"math/polyhedra\"\nimport { andaleMono } from \"styles/fonts\"\nimport { hover } from \"styles/common\"\n\nfunction ResetButton(props: ButtonHTMLAttributes<Element>) {\n  const css = useStyle({\n    ...hover,\n    alignSelf: \"flex-end\",\n    backgroundColor: \"white\",\n    border: \"1px LightGray solid\",\n    padding: scales.spacing[2],\n    fontSize: scales.font[6],\n    fontFamily: andaleMono,\n  })\n  return <button {...props} {...css()} />\n}\n\nconst buttons = [\n  {\n    name: \"Recenter\",\n    handler: (polyhedron: Polyhedron) => polyhedron.center(),\n  },\n  {\n    name: \"Resize\",\n    handler: (polyhedron: Polyhedron) => polyhedron.normalizeToVolume(5),\n  },\n]\n\nexport default function ResizeButtons() {\n  const polyhedron = PolyhedronCtx.useState()\n  const { setPolyhedron } = PolyhedronCtx.useActions()\n  const { isTransitioning } = TransitionCtx.useState()\n\n  const css = useStyle({\n    display: \"grid\",\n    gridTemplateColumns: \"1fr 1fr\",\n    columnGap: scales.spacing[2],\n  })\n  return (\n    <div {...css()}>\n      {buttons.map(({ name, handler }) => (\n        <ResetButton\n          key={name}\n          disabled={isTransitioning}\n          onClick={() =>\n            setPolyhedron(\n              createForme(polyhedron.specs, handler(polyhedron.geom)),\n            )\n          }\n        >\n          {name}\n        </ResetButton>\n      ))}\n    </div>\n  )\n}\n","import React, { useCallback } from \"react\"\nimport Icon from \"@mdi/react\"\nimport { mdiRotateLeft, mdiRotateRight } from \"@mdi/js\"\n\nimport { Twist } from \"specs\"\nimport { useStyle, scales } from \"styles\"\nimport { flexRow, square, flexColumn, hover } from \"styles/common\"\nimport { SrOnly } from \"components/common\"\nimport { useApplyOperation, TransitionCtx, OperationCtx } from \"../../context\"\n\nfunction TwistOption({ orientation }: { orientation: Twist }) {\n  const { isTransitioning } = TransitionCtx.useState()\n  const { operation } = OperationCtx.useState()\n  const applyOperation = useApplyOperation()\n  const handleClick = useCallback(\n    () => applyOperation(operation!, { twist: orientation }),\n    [orientation, operation, applyOperation],\n  )\n\n  const css = useStyle({\n    ...flexColumn(\"center\", \"center\"),\n    ...square(scales.size[3]),\n    ...hover,\n    border: \"1px LightGray solid\",\n    pointerEvents: \"initial\",\n    background: \"none\",\n  })\n  return (\n    <button {...css()} disabled={isTransitioning} onClick={handleClick}>\n      <Icon\n        path={orientation === \"left\" ? mdiRotateLeft : mdiRotateRight}\n        rotate={180}\n        size={scales.size[3]}\n      />\n      <SrOnly>{orientation}</SrOnly>\n    </button>\n  )\n}\n\nexport default function TwistOptions() {\n  const css = useStyle({\n    ...flexRow(\"center\", \"space-between\"),\n    width: \"100%\",\n    height: \"100%\",\n  })\n  return (\n    <div {...css()}>\n      <TwistOption orientation=\"left\" />\n      <TwistOption orientation=\"right\" />\n    </div>\n  )\n}\n","import { take } from \"lodash-es\"\n\nimport React, { memo } from \"react\"\n\nimport { useStyle, scales } from \"styles\"\nimport {\n  Point2D,\n  Polygon,\n  PolyLine,\n  PolyShape,\n  polygonPoints,\n} from \"components/svg\"\nimport { square } from \"styles/common\"\n\ninterface Props {\n  name: string\n}\n\nconst color = \"DimGray\"\n\nfunction InnerIcon({ name }: Props) {\n  const inner = useStyle({\n    stroke: color,\n    fill: \"none\",\n    strokeWidth: 5,\n    strokeLinejoin: \"round\",\n  })\n  const outer = useStyle({\n    stroke: color,\n    fill: \"none\",\n    strokeWidth: 8,\n    strokeLinejoin: \"round\",\n  })\n\n  switch (name) {\n    case \"ortho\":\n      return (\n        <>\n          <Polygon {...outer()} n={5} cx={100} cy={100} a={90} r={100} />\n          <Polygon {...inner()} n={5} cx={100} cy={100} a={90} r={66} />\n        </>\n      )\n    case \"gyro\":\n      return (\n        <>\n          <Polygon {...outer()} n={5} cx={100} cy={100} a={90} r={100} />\n          <Polygon {...inner()} n={5} cx={100} cy={100} a={-90} r={66} />\n        </>\n      )\n    case \"cupola\": {\n      const center = 100\n      const height = 50\n      const topY = center - height\n      const bottomY = center + height\n      const topWidth = 50\n      const bottomWidth = 90\n      const topLeftX = center - topWidth\n      const topRightX = center + topWidth\n      return (\n        <>\n          <PolyShape\n            {...outer()}\n            points={[\n              [topRightX, topY],\n              [topLeftX, topY],\n              [center - bottomWidth, bottomY],\n              [center + bottomWidth, bottomY],\n            ]}\n          />\n          <PolyLine\n            {...inner()}\n            points={[\n              [topLeftX, topY],\n              [topLeftX, bottomY],\n              [topRightX, bottomY],\n              [topRightX, topY],\n            ]}\n          />\n        </>\n      )\n    }\n    case \"rotunda\": {\n      const points = take(polygonPoints({ n: 12, cx: 100, cy: 150, r: -90 }), 7)\n      const [p1, p2, p3, p4, p5, p6] = points\n      const bottomY = p1[1]\n      const q1: Point2D = [p3[0], p2[1]]\n      const q2: Point2D = [p5[0], p6[1]]\n      return (\n        <>\n          <PolyShape {...outer()} points={points} />\n          <PolyShape\n            {...inner()}\n            points={[[70, bottomY], q1, p4, q2, [130, bottomY]]}\n          />\n          <PolyLine\n            {...inner()}\n            points={[p3, q1, [40, bottomY], [160, bottomY], q2, p5]}\n          />\n        </>\n      )\n    }\n    default:\n      throw new Error(\"unknown icon type\")\n  }\n}\nexport default memo(function OptionIcon({ name }: Props) {\n  const css = useStyle(square(scales.size[2]))\n  return (\n    <svg viewBox=\"0 0 200 200\" {...css()}>\n      <InnerIcon name={name} />\n    </svg>\n  )\n})\n","import React, { ButtonHTMLAttributes } from \"react\"\nimport { useStyle, scales } from \"styles\"\n\nimport { PolyhedronCtx, OperationCtx } from \"components/ViewerPage/context\"\nimport OptionIcon from \"./OptionIcon\"\nimport { verdana } from \"styles/fonts\"\nimport { hover, square, flexRow, flexColumn } from \"styles/common\"\n\ninterface BtnProps extends ButtonHTMLAttributes<HTMLButtonElement> {\n  optValue: string\n  selected: boolean\n}\n\nfunction OptionButton({ optValue, selected, ...htmlProps }: BtnProps) {\n  const css = useStyle(\n    {\n      ...hover,\n      ...square(scales.size[3]),\n      border: selected ? \"2px DarkSlateGray solid\" : \"1px LightGray solid\",\n      backgroundColor: \"white\",\n      fontFamily: verdana,\n    },\n    [selected],\n  )\n  return (\n    <button {...htmlProps} {...css()}>\n      <OptionIcon name={optValue} />\n      {optValue}\n    </button>\n  )\n}\n\nexport default function AugmentOptions() {\n  const polyhedron = PolyhedronCtx.useState()\n  const { operation, options } = OperationCtx.useState()\n  const { setOption } = OperationCtx.useActions()\n\n  const css = useStyle({\n    ...flexRow(\"center\", \"space-between\"),\n    width: \"100%\",\n    height: \"100%\",\n  })\n\n  const optionCss = useStyle({\n    ...flexColumn(),\n    pointerEvents: \"initial\",\n  })\n\n  return (\n    <div {...css()}>\n      {[\"gyrate\", \"using\"].map((name) => {\n        const value = options![name]\n        return (\n          <div key={name} {...optionCss()}>\n            {operation?.allOptions(polyhedron, name).map((optValue) => (\n              <OptionButton\n                key={optValue}\n                optValue={optValue}\n                onClick={() => setOption(name, optValue)}\n                disabled={!value}\n                selected={value === optValue}\n              />\n            ))}\n          </div>\n        )\n      })}\n    </div>\n  )\n}\n","import React from \"react\"\n\nimport { OperationCtx } from \"components/ViewerPage/context\"\nimport TwistOptions from \"./TwistOptions\"\nimport AugmentOptions from \"./AugmentOptions\"\n\nfunction hasTwist(opName: string) {\n  return [\"snub\", \"twist\", \"gyroelongate\", \"shorten\", \"turn\"].includes(opName)\n}\n\nexport default function Options() {\n  const { operation } = OperationCtx.useState()\n  if (!operation) return null\n  if (operation.name === \"augment\") return <AugmentOptions />\n  if (hasTwist(operation.name)) return <TwistOptions />\n  return null\n}\n","import { zip } from \"lodash-es\"\nimport { SolidData } from \"math/polyhedra\"\nimport React, { useRef, useMemo } from \"react\"\nimport {\n  Color,\n  Vector3,\n  BufferAttribute,\n  DoubleSide,\n  Face3,\n  BufferGeometry,\n  FrontSide,\n  Geometry,\n} from \"three\"\nimport { useFrame, useUpdate } from \"react-three-fiber\"\n\nfunction convertFace(face: number[], color: Color) {\n  const [v0, ...vs] = face\n  const pairs = zip(vs.slice(0, vs.length - 1), vs.slice(1))\n  return pairs.map(([v1, v2]) => {\n    return new Face3(v0, v1!, v2!, undefined, color)\n  })\n}\n\nfunction convertFaces(faces: number[][], colors: Color[]) {\n  return zip(faces, colors).flatMap(([face, color]) =>\n    convertFace(face!, color!),\n  )\n}\n\ninterface SolidConfig {\n  showFaces: boolean\n  showEdges: boolean\n  showInnerFaces: boolean\n  opacity: number\n}\n\ninterface Props {\n  value: SolidData\n  colors: Color[]\n  config: SolidConfig\n  onClick?(point: Vector3): void\n  onPointerMove?(point: Vector3): void\n  onPointerOut?(point: Vector3): void\n}\n\nexport default function ThreePolyhedron({\n  onClick,\n  onPointerMove,\n  onPointerOut,\n  value,\n  colors,\n  config,\n}: Props) {\n  const { vertices, faces, edges = [] } = value\n  const hasMoved = useRef(false)\n  const { showFaces, showEdges, showInnerFaces, opacity } = config\n\n  const ref = useUpdate(\n    (geom: Geometry) => {\n      geom.vertices = vertices\n      geom.verticesNeedUpdate = true\n      geom.faces = convertFaces(faces, colors)\n      geom.elementsNeedUpdate = true\n      geom.colorsNeedUpdate = true\n      geom.computeFaceNormals()\n    },\n    [vertices, faces, colors],\n  )\n\n  const edgeGeom = useMemo(() => {\n    const geom = new BufferGeometry()\n    const positions = new Float32Array(300 * 3) // 3 vertices per point\n    geom.setAttribute(\"position\", new BufferAttribute(positions, 3))\n    return geom\n  }, [])\n\n  useFrame(() => {\n    const positions = edgeGeom.attributes.position.array as number[]\n    edges.forEach((edge: [number, number], i: number) => {\n      const [i1, i2] = edge\n      const vs = [...vertices[i1].toArray(), ...vertices[i2].toArray()]\n      for (let j = 0; j < 6; j++) {\n        positions[i * 6 + j] = vs[j]\n      }\n    })\n    edgeGeom.setDrawRange(0, edges.length * 2)\n    edgeGeom.attributes.position.needsUpdate = true\n  })\n\n  return (\n    <>\n      {showFaces && (\n        <mesh\n          onPointerDown={(e) => {\n            hasMoved.current = false\n          }}\n          onPointerUp={(e) => {\n            if (hasMoved.current) return\n            onClick?.(e.point)\n          }}\n          onPointerMove={(e) => {\n            hasMoved.current = true\n            onPointerMove?.(e.point)\n          }}\n          onPointerOut={(e) => {\n            onPointerOut?.(e.point)\n          }}\n        >\n          <geometry ref={ref} attach=\"geometry\" />\n          <meshStandardMaterial\n            side={showInnerFaces ? DoubleSide : FrontSide}\n            attach=\"material\"\n            color=\"grey\"\n            args={[{ vertexColors: true }]}\n            transparent={opacity < 1}\n            opacity={opacity}\n          />\n        </mesh>\n      )}\n      {showEdges && (\n        <lineSegments geometry={edgeGeom}>\n          <lineBasicMaterial\n            attach=\"material\"\n            color={0x444444}\n            linewidth={1}\n            transparent\n            opacity={0.8}\n          />\n        </lineSegments>\n      )}\n    </>\n  )\n}\n","import { Color } from \"three\"\nimport { useMemo, useCallback } from \"react\"\nimport Config from \"components/ConfigCtx\"\nimport { PolyhedronCtx, OperationCtx, TransitionCtx } from \"../../context\"\nimport { Polyhedron, Face } from \"math/polyhedra\"\nimport ClassicalForme from \"math/formes/ClassicalForme\"\nimport CapstoneForme from \"math/formes/CapstoneForme\"\nimport CompositeForme from \"math/formes/CompositeForme\"\nimport PolyhedronForme from \"math/formes/PolyhedronForme\"\n\nfunction toColor(color: any): Color {\n  if (color instanceof Color) return color\n  return new Color(color)\n}\n\nfunction lighten(color: Color, amount: number) {\n  return toColor(color)\n    .clone()\n    .offsetHSL(0, 0, amount / 100)\n}\n\nfunction darken(color: Color, amount: number) {\n  return toColor(color)\n    .clone()\n    .offsetHSL(0, 0, -amount / 100)\n}\n\nfunction createFamilyColor(face: string, vertex: string) {\n  const faceColor = new Color(face)\n  const vertexColor = new Color(vertex)\n  return {\n    primary: { face: faceColor, vertex: vertexColor },\n    secondary: {\n      face: faceColor.clone().offsetHSL(0, 0, -1 / 4),\n      vertex: vertexColor.clone().offsetHSL(0, 0, -1 / 4),\n    },\n    edge: {\n      ortho: faceColor\n        .clone()\n        .lerp(vertexColor, 1 / 3)\n        .offsetHSL(0, -1 / 4, 1 / 10),\n      gyro: faceColor\n        .clone()\n        .lerp(vertexColor, 2 / 3)\n        .offsetHSL(0, -1 / 4, 1 / 10),\n    },\n  }\n}\n\nconst colorScheme = {\n  2: createFamilyColor(\"#000000\", \"#ffffff\"),\n  // green + cyan\n  3: createFamilyColor(\"#1bcc3b\", \"#15ace8\"),\n  // red + yellow\n  4: createFamilyColor(\"#ff3d3d\", \"#ffe100\"),\n  // blue + magenta\n  5: createFamilyColor(\"#424eed\", \"#f24bd4\"),\n}\n\nfunction getClassicalColor(forme: ClassicalForme, face: Face) {\n  const scheme = colorScheme[forme.specs.data.family]\n  const facet = forme.getFacet(face)\n  // thing for the edge face\n  if (!facet) {\n    return scheme.edge[forme.specs.isSnub() ? \"gyro\" : \"ortho\"]\n  }\n  const faceSides = face.numSides > 5 ? \"secondary\" : \"primary\"\n  return scheme[faceSides][facet]\n}\n\nfunction getCapstoneColor(forme: CapstoneForme, face: Face) {\n  const scheme = colorScheme[forme.specs.data.base]\n  if (forme.isBaseTop(face)) {\n    const faceSides = face.numSides > 5 ? \"secondary\" : \"primary\"\n    return scheme[faceSides].face\n  } else if (forme.inBase(face)) {\n    if (face.numSides === 3) {\n      return scheme.primary.vertex\n    } else if (face.numSides === 4) {\n      // TODO need to distinguish this from the edge faces\n      return scheme.edge.ortho\n    } else {\n      // TODO want this to be a separate color from the top face\n      return colorScheme[5].primary.face\n    }\n  } else {\n    const side = forme.specs.isElongated() ? \"ortho\" : (\"gyro\" as const)\n    return scheme.edge[side].clone().offsetHSL(0, -1 / 50, 1 / 100)\n  }\n}\n\nfunction getCompositeColor(forme: CompositeForme, face: Face) {\n  if (forme.isAugmentedPrism()) {\n    const sourceSpecs = forme.specs.sourcePrism()\n    const scheme = colorScheme[sourceSpecs.data.base]\n    if (forme.isBaseFace(face)) {\n      return scheme[sourceSpecs.data.type].face\n    } else if (forme.isSideFace(face)) {\n      return scheme.edge.ortho\n    } else {\n      // augmented face\n      return scheme.primary.vertex.clone().offsetHSL(0, 0, 1 / 4)\n    }\n  } else if (forme.isAugmentedClassical()) {\n    const scheme = colorScheme[forme.specs.sourceClassical().data.family]\n    const type = forme.specs.sourceClassical().isTruncated()\n      ? \"secondary\"\n      : (\"primary\" as const)\n    if (forme.isMainFace(face)) {\n      return scheme[type].face\n    } else if (forme.isMinorFace(face)) {\n      return scheme.primary.vertex\n    } else if (forme.isCapTop(face)) {\n      return lighten(scheme.primary.face, 25)\n    } else {\n      return lighten(\n        face.numSides === 3 ? scheme.primary.vertex : scheme.edge.ortho,\n        25,\n      )\n    }\n  } else if (forme.isDiminishedSolid()) {\n    const scheme = colorScheme[5]\n    if (forme.isAugmentedFace(face)) {\n      return lighten(scheme.primary.vertex, 25)\n    } else if (forme.isDiminishedFace(face)) {\n      return darken(scheme.primary.face, 25)\n    } else {\n      return scheme.primary.vertex\n    }\n  }\n}\n\nfunction getFormeColor(polyhedron: PolyhedronForme, face: Face) {\n  if (polyhedron instanceof ClassicalForme) {\n    return getClassicalColor(polyhedron, face)\n  } else if (polyhedron instanceof CapstoneForme) {\n    return getCapstoneColor(polyhedron, face)\n  } else if (polyhedron instanceof CompositeForme) {\n    return getCompositeColor(polyhedron, face)\n  }\n}\n\n// Hook that takes data from Polyhedron and Animation states and decides which to use.\nexport default function useSolidContext() {\n  const { enableFormeColors, colors } = Config.useState()\n  const polyhedron = PolyhedronCtx.useState()\n\n  const {\n    solidData,\n    isTransitioning,\n    faceColors = [],\n  } = TransitionCtx.useState()\n  const { operation, options = {} } = OperationCtx.useState()\n\n  const getSelectionColor = useCallback(\n    (face, color) => {\n      if (!operation) return color\n      switch (operation.selectionState(face, polyhedron, options)) {\n        case \"selected\":\n          return lighten(color, 25)\n        case \"selectable\":\n          return lighten(color, 10)\n        default:\n          return color\n      }\n    },\n    [operation, options, polyhedron],\n  )\n\n  const formeColors = useMemo(() => {\n    if (!enableFormeColors) return\n    return polyhedron.geom.faces.map((f) =>\n      getSelectionColor(f, getFormeColor(polyhedron, f)),\n    )\n  }, [polyhedron, enableFormeColors, getSelectionColor])\n\n  // Colors when animation is being applied\n  const transitionColors = useMemo(() => {\n    return isTransitioning && faceColors\n  }, [faceColors, isTransitioning])\n  const geom: Polyhedron = polyhedron.geom\n\n  // Colors when in operation mode and hit options are being selected\n  const operationColors = useMemo(() => {\n    return geom.faces.map((face) =>\n      getSelectionColor(face, colors[face.numSides]),\n    )\n  }, [colors, geom.faces, getSelectionColor])\n\n  const normalizedColors: Color[] = useMemo(() => {\n    const rawColors =\n      transitionColors ||\n      formeColors ||\n      operationColors ||\n      geom.faces.map((f) => colors[f.numSides])\n    return rawColors.map(toColor)\n  }, [formeColors, transitionColors, operationColors, geom, colors])\n\n  return {\n    colors: normalizedColors,\n    solidData: isTransitioning ? solidData! : polyhedron.geom.solidData,\n  }\n}\n","import { pick } from \"lodash-es\"\nimport React, { useEffect, useRef } from \"react\"\nimport { PerspectiveCamera } from \"three\"\nimport { Canvas, extend, useThree, useFrame } from \"react-three-fiber\"\nimport { TrackballControls } from \"three/examples/jsm/controls/TrackballControls\"\nimport ThreePolyhedron from \"./ThreePolyhedron\"\nimport useSolidContext from \"./useSolidContext\"\nimport useHitOptions from \"./useHitOptions\"\nimport ConfigCtx from \"components/ConfigCtx\"\n\nextend({ TrackballControls })\n\nfunction CameraControls() {\n  const {\n    setDefaultCamera,\n    gl: { domElement },\n  } = useThree()\n  // Ref to the controls, so that we can update them on every frame using useFrame\n  const camera = useRef<PerspectiveCamera | undefined>()\n  const controls = useRef<TrackballControls | undefined>()\n  useEffect(() => {\n    if (camera.current) setDefaultCamera(camera.current)\n  }, [setDefaultCamera])\n  useFrame(() => {\n    camera.current?.updateMatrixWorld()\n    controls.current?.update()\n  })\n  // FIXME v4 This needs to adjusted when resizing\n  return (\n    <>\n      <perspectiveCamera ref={camera} position={[0, 0, 5]}>\n        <pointLight />\n      </perspectiveCamera>\n      {camera.current && (\n        <trackballControls\n          ref={controls}\n          args={[camera.current, domElement]}\n          enabled\n          noPan\n          rotateSpeed={8.0}\n          staticMoving // TODO make this configurable\n        />\n      )}\n    </>\n  )\n}\n\nexport default function ThreeScene() {\n  const { colors, solidData } = useSolidContext()\n  const { setHitOption, unsetHitOption, applyWithHitOption } = useHitOptions()\n  const config = ConfigCtx.useState()\n  return (\n    <Canvas gl={{ antialias: true }}>\n      <CameraControls />\n      <ambientLight />\n      <ThreePolyhedron\n        value={solidData}\n        colors={colors}\n        config={pick(config, [\n          \"showFaces\",\n          \"showEdges\",\n          \"showInnerFaces\",\n          \"opacity\",\n        ])}\n        onPointerMove={setHitOption}\n        onClick={applyWithHitOption}\n        onPointerOut={unsetHitOption}\n      />\n    </Canvas>\n  )\n}\n","// import SolidScene from \"./SolidScene\"\nimport ThreeScene from \"./ThreeScene\"\nexport default ThreeScene\n","import { useCallback } from \"react\"\nimport { isEmpty, isEqual } from \"lodash-es\"\nimport { Vector3 } from \"three\"\n\nimport { Cap } from \"math/polyhedra\"\nimport {\n  PolyhedronCtx,\n  OperationCtx,\n  TransitionCtx,\n  useApplyOperation,\n} from \"../../context\"\n\nexport default function useHitOptions() {\n  const polyhedron = PolyhedronCtx.useState()\n  const { isTransitioning } = TransitionCtx.useState()\n  const { operation, options = {} } = OperationCtx.useState()\n  const { setOption } = OperationCtx.useActions()\n  const applyOperation = useApplyOperation()\n  const { hitOption = \"\" } = operation ?? {}\n\n  const setHitOption = (hitPnt: Vector3) => {\n    if (!operation || isTransitioning) return\n    const newHitOptions = operation.getHitOption(polyhedron, hitPnt, options)\n    if (isEmpty(newHitOptions)) {\n      return setOption(hitOption, undefined)\n    }\n    const newValue = newHitOptions[hitOption]\n    if (!isEqual(options[hitOption], newValue)) {\n      setOption(hitOption, newValue)\n    }\n  }\n\n  const unsetHitOption = () => {\n    if (!operation) return\n    setOption(hitOption, undefined)\n  }\n  const applyWithHitOption = useCallback(\n    (hitPnt: Vector3) => {\n      if (!operation || isTransitioning) return\n      const newHitOptions = operation.getHitOption(polyhedron, hitPnt, options)\n      const newValue = newHitOptions[hitOption]\n      // only apply operation if we have a hit\n      if (options && newValue) {\n        applyOperation(\n          operation,\n          { ...options, [hitOption]: newValue },\n          (result) => {\n            // If we're still on a cap, select it\n            if (hitOption === \"cap\" && options[hitOption]) {\n              setOption(\"cap\", Cap.find(result, options[hitOption].topPoint))\n            }\n          },\n        )\n      }\n    },\n    [\n      operation,\n      applyOperation,\n      hitOption,\n      isTransitioning,\n      options,\n      polyhedron,\n      setOption,\n    ],\n  )\n  return { setHitOption, unsetHitOption, applyWithHitOption }\n}\n","import React from \"react\"\nimport { NavLink, NavLinkProps } from \"react-router-dom\"\nimport { useStyle, scales } from \"styles\"\nimport Icon from \"@mdi/react\"\n\nimport { media, fonts } from \"styles\"\nimport { SrOnly } from \"components/common\"\nimport { colorFill, flexColumn } from \"styles/common\"\n\ninterface Props extends NavLinkProps {\n  iconName: string\n  iconOnly?: boolean\n  title: string\n}\n\nfunction LinkText({ text, hidden }: { text: string; hidden: boolean }) {\n  const css = useStyle({\n    marginTop: scales.spacing[1],\n    fontSize: scales.font[7],\n    fontFamily: fonts.verdana,\n\n    [media.mobileLandscape]: {\n      marginTop: 0,\n      paddingLeft: scales.spacing[1],\n    },\n  })\n  return hidden ? <SrOnly>{text}</SrOnly> : <div {...css()}>{text}</div>\n}\n\nexport default function IconLink({\n  iconName,\n  title,\n  to,\n  replace,\n  onClick,\n  iconOnly = false,\n}: Props) {\n  const css = useStyle({\n    ...flexColumn(\"center\"),\n    ...colorFill(\"DimGray\"),\n    textDecoration: \"none\",\n    padding: scales.spacing[2],\n\n    [media.mobileLandscape]: {\n      padding: 0,\n      flexDirection: \"row\",\n    },\n  })\n\n  const activeCss = useStyle(colorFill(\"DarkSlateGray\"))\n\n  return (\n    <NavLink\n      to={to}\n      replace={replace}\n      {...css()}\n      {...activeCss(\"activeClassName\")}\n      onClick={onClick}\n    >\n      <Icon path={iconName} size={scales.size[2]} />\n      <LinkText text={title} hidden={iconOnly} />\n    </NavLink>\n  )\n}\n","import React from \"react\"\nimport { mdiChevronLeft } from \"@mdi/js\"\nimport { escape } from \"utils\"\n\nimport IconLink from \"./IconLink\"\n\ninterface Props {\n  solid: string\n}\n\nexport default function BackLink({ solid }: Props) {\n  return (\n    <IconLink\n      iconOnly\n      iconName={mdiChevronLeft}\n      title=\"Back\"\n      to={`/#${escape(solid)}`}\n    />\n  )\n}\n","import { capitalize } from \"lodash-es\"\nimport React from \"react\"\nimport {\n  mdiFormatListBulleted,\n  mdiInformationOutline,\n  mdiCog,\n  mdiMathCompass,\n  mdiCubeOutline,\n} from \"@mdi/js\"\n\nimport { useStyle } from \"styles\"\nimport IconLink from \"./IconLink\"\n\ninterface Props {\n  compact?: boolean\n  onClick(): void\n}\n\nconst links = [\n  { name: \"list\", icon: mdiFormatListBulleted },\n  { name: \"info\", icon: mdiInformationOutline },\n  { name: \"options\", icon: mdiCog },\n  { name: \"operations\", icon: mdiMathCompass },\n  { name: \"full\", title: \"Fullscreen\", icon: mdiCubeOutline },\n]\n\nexport default function NavMenu({ compact = false, onClick }: Props) {\n  const css = useStyle({\n    // Using grid here bc it's easier to get evenly spaced than flex\n    display: \"grid\",\n    gridTemplateColumns: `repeat(${links.length}, 1fr)`,\n    justifyItems: \"center\",\n    width: \"100%\",\n  })\n\n  return (\n    <nav {...css()}>\n      {links.map(({ name, title = name, icon }) => (\n        <IconLink\n          key={name}\n          replace\n          to={`../${name}`}\n          title={capitalize(title)}\n          iconName={icon}\n          iconOnly={compact}\n          onClick={onClick}\n        />\n      ))}\n    </nav>\n  )\n}\n","import React from \"react\"\nimport Icon from \"@mdi/react\"\n\nimport { useStyle, scales } from \"styles\"\nimport { SrOnly } from \"components/common\"\nimport { fonts } from \"styles\"\n\nimport { RawSolidData } from \"math/polyhedra\"\nimport { hover } from \"styles/common\"\nimport { mdiDownload } from \"@mdi/js\"\n\nfunction formatDecimal(number: number) {\n  return Number.isInteger(number) ? `${number}.0` : number\n}\n\nfunction vToObj(vertex: number[]) {\n  return \"v \" + vertex.map(formatDecimal).join(\" \")\n}\n\nfunction fToObj(face: number[]) {\n  return \"f \" + face.map((i) => i + 1).join(\" \")\n}\n\nfunction toObj({ vertices, faces }: RawSolidData) {\n  const vObj = vertices.map(vToObj)\n  const fObj = faces.map(fToObj)\n  return vObj.concat(fObj).join(\"\\n\")\n}\n\nconst fileFormats = [\n  {\n    ext: \"json\",\n    serializer: JSON.stringify,\n  },\n  {\n    ext: \"obj\",\n    serializer: toObj,\n  },\n]\n\ninterface Props {\n  name: string\n  solid: RawSolidData\n}\n\nfunction DownloadLink({\n  ext,\n  serializer,\n  solid,\n  name,\n}: typeof fileFormats[0] & Props) {\n  const filename = `${name}.${ext}`\n  const blob = new Blob([serializer(solid)], {\n    type: \"text/plain;charset=utf-8\",\n  })\n  const url = window.URL.createObjectURL(blob)\n\n  const css = useStyle({\n    display: \"inline-flex\",\n    justifyContent: \"center\",\n    padding: scales.spacing[2],\n    width: scales.size[4],\n\n    textDecoration: \"none\",\n    border: \"1px LightGray solid\",\n    color: \"black\",\n    fontFamily: fonts.andaleMono,\n    ...hover,\n\n    \":not(:last-child)\": {\n      marginRight: scales.spacing[2],\n    },\n  })\n\n  return (\n    <a {...css()} key={ext} download={filename} href={url}>\n      <SrOnly>Download as</SrOnly>.{ext}{\" \"}\n      <span>\n        <Icon path={mdiDownload} size={scales.size[1]} />\n      </span>\n    </a>\n  )\n}\n\nexport default function DataDownloader({ solid, name }: Props) {\n  const heading = useStyle({\n    fontFamily: fonts.times,\n    fontSize: scales.font[4],\n    marginBottom: scales.spacing[2],\n  })\n  return (\n    <div>\n      <h2 {...heading()}>Download model</h2>\n      <div>\n        {fileFormats.map((format) => (\n          <DownloadLink\n            key={format.ext}\n            {...format}\n            name={name}\n            solid={solid}\n          />\n        ))}\n      </div>\n    </div>\n  )\n}\n","import React from \"react\"\nimport { capitalize, map } from \"lodash-es\"\nimport { ChildrenProp } from \"types\"\nimport { PolyhedronSpecs, polygonNames } from \"specs\"\nimport { Polyhedron } from \"math/polyhedra\"\nimport { useStyle } from \"styles\"\n\nexport function Sub({ children }: ChildrenProp) {\n  const css = useStyle({\n    verticalAlign: \"sub\",\n    fontSize: \"smaller\",\n  })\n  return <sub {...css()}>{children}</sub>\n}\n\nexport function Sup({ children }: ChildrenProp<number>) {\n  if (typeof children === \"undefined\") {\n    throw new Error(\"undefined child\")\n  }\n  if (children < 0 || children > 5) {\n    throw new Error(\"Number not supported\")\n  }\n  const value = (() => {\n    switch (children) {\n      case 1:\n        return <>&#x00B9;</>\n      case 2:\n        return <>&#x00B2;</>\n      case 3:\n        return <>&#x00B3;</>\n      case 4:\n        return <>&#x2074;</>\n      case 5:\n        return <>&#x2075;</>\n      default:\n        return children\n    }\n  })()\n  const css = useStyle({ fontSize: 20 })\n  return <sup {...css()}>{value}</sup>\n}\n\nfunction* groupedVertexConfig(config: string) {\n  const array = config.split(\".\")\n  let current = { type: \"\", count: 0 }\n  for (const type of array) {\n    if (type === current.type) {\n      current.count++\n    } else {\n      if (current.count) yield current\n      current = { type, count: 1 }\n    }\n  }\n  if (current.count) yield current\n}\n\nfunction getShortVertexConfig(config: string) {\n  const grouped = [...groupedVertexConfig(config)]\n  const children = grouped.map((typeCount, i) => {\n    const { type, count } = typeCount\n    const val =\n      count === 1 ? (\n        type\n      ) : (\n        <>\n          {type}\n          <Sup>{count}</Sup>\n        </>\n      )\n    if (i === 0) return val\n    return <>.{val}</>\n  })\n  return <>{children}</>\n}\n\nexport interface RenderProps {\n  polyhedron: Polyhedron\n  info: PolyhedronSpecs\n}\n\nexport function displayVertexConfig({ polyhedron }: RenderProps) {\n  const vConfig = polyhedron.vertexConfiguration()\n  const configKeys = Object.keys(vConfig)\n  // When there's only one type, just get it on its own\n  if (configKeys.length === 1) return <>{configKeys[0]}</>\n  return (\n    <ul>\n      {map(vConfig, (count, type) => (\n        <li key={type}>\n          {count}({getShortVertexConfig(type)})\n        </li>\n      ))}\n    </ul>\n  )\n}\n\nexport function displayFaceTypes({ polyhedron }: RenderProps) {\n  const faceCounts = polyhedron.numFacesBySides()\n  // TODO verify order by type of face\n  return (\n    <ul>\n      {map(faceCounts, (count, type) => (\n        <li key={type}>\n          {count} {polygonNames.get(parseInt(type) as any)}\n          {count !== 1 ? \"s\" : \"\"}\n        </li>\n      ))}\n    </ul>\n  )\n}\n\nexport function displaySymmetry({ info }: RenderProps) {\n  const { base, sub } = info.symmetry().symbol()\n  const symName = info.symmetry().name()\n  return (\n    <>\n      {capitalize(symName)}, {base}\n      {sub ? <Sub>{sub}</Sub> : undefined}\n    </>\n  )\n}\n\ninterface Properties {\n  name: string\n  check(info: PolyhedronSpecs, p: Polyhedron): boolean\n}\n\nconst properties: Properties[] = [\n  { name: \"deltahedron\", check: (_, p) => p.isDeltahedron() },\n  { name: \"chiral\", check: (info) => info.isChiral() },\n  { name: \"honeycomb\", check: (info) => info.isHoneycomb() },\n]\n\nexport function displayProperties({ info, polyhedron }: RenderProps) {\n  const filteredProps = properties.filter((property) =>\n    property.check(info, polyhedron),\n  )\n\n  return <>{filteredProps.map((prop) => prop.name).join(\", \") || \"--\"}</>\n}\n","import React, { ComponentType } from \"react\"\nimport { round } from \"lodash-es\"\nimport { Link } from \"react-router-dom\"\n\nimport { escape } from \"utils\"\nimport { fonts, useStyle, scales } from \"styles\"\n\nimport {\n  Sup,\n  RenderProps,\n  displayFaceTypes,\n  displayVertexConfig,\n  displaySymmetry,\n  displayProperties,\n} from \"./renderFuncs\"\n\ninterface InfoRow {\n  name: string\n  area: string\n  render: ComponentType<RenderProps>\n}\n\nconst infoRows: InfoRow[] = [\n  {\n    name: \"Vertices\",\n    area: \"verts\",\n    render: ({ polyhedron }) => <>{polyhedron.numVertices()}</>,\n  },\n  {\n    name: \"Edges\",\n    area: \"edges\",\n    render: ({ polyhedron }) => <>{polyhedron.numEdges()}</>,\n  },\n  {\n    name: \"Faces\",\n    area: \"faces\",\n    render: ({ polyhedron }) => <>{polyhedron.numFaces()}</>,\n  },\n  {\n    name: \"Vertex configuration\",\n    area: \"vconf\",\n    render: displayVertexConfig,\n  },\n  {\n    name: \"Faces by type\",\n    area: \"ftype\",\n    render: displayFaceTypes,\n  },\n\n  {\n    name: \"Volume\",\n    area: \"vol\",\n    render: ({ polyhedron: p }) => (\n      <>\n        ≈{round(p.normalizedVolume(), 3)}s<Sup>{3}</Sup>\n      </>\n    ),\n  },\n  {\n    name: \"Surface area\",\n    area: \"sa\",\n    render: ({ polyhedron: p }) => (\n      <>\n        ≈{round(p.normalizedSurfaceArea(), 3)}s<Sup>{2}</Sup>\n      </>\n    ),\n  },\n  {\n    name: \"Sphericity\",\n    area: \"spher\",\n    render: ({ polyhedron: p }) => <>≈{round(p.sphericity(), 3)}</>,\n  },\n\n  { name: \"Symmetry\", area: \"sym\", render: displaySymmetry },\n  {\n    name: \"Order\",\n    area: \"order\",\n    render: ({ info }) => <>{info.symmetry().order()}</>,\n  },\n  {\n    name: \"Properties\",\n    area: \"props\",\n    render: displayProperties,\n  },\n  {\n    name: \"Also known as\",\n    area: \"alt\",\n    render: ({ info }: RenderProps) => {\n      const alts = info.alternateNames()\n      if (alts.length === 0) return <>--</>\n      return (\n        <ul>\n          {alts.map((alt) => (\n            <li key={alt}>\n              <Link to={`/${escape(alt)}/info`}>{alt}</Link>\n            </li>\n          ))}\n        </ul>\n      )\n    },\n  },\n]\n\nfunction Datum({\n  info,\n  polyhedron,\n  name,\n  area,\n  render: Renderer,\n}: InfoRow & RenderProps) {\n  const css = useStyle({ marginBottom: 10 })\n  const nameCss = useStyle({\n    fontSize: scales.font[5],\n    marginBottom: scales.spacing[1],\n  })\n  const valueCss = useStyle({\n    fontFamily: fonts.andaleMono,\n    color: \"DimGrey\",\n  })\n\n  return (\n    <div {...css()} style={{ gridArea: area }}>\n      <dd {...nameCss()}>{name}</dd>\n      <dt {...valueCss()}>\n        <Renderer polyhedron={polyhedron} info={info} />\n      </dt>\n    </div>\n  )\n}\n\nexport default function DataList(props: RenderProps) {\n  const css = useStyle({\n    display: \"grid\",\n    gridTemplateAreas: `\n      \"verts verts edges edges faces faces\"\n      \"vconf vconf vconf ftype ftype ftype\"\n      \"vol   vol   sa    sa    spher spher\"\n      \"sym   sym   sym   sym   order order\"\n      \"props props props props props props\"\n      \"alt   alt   alt   alt   alt   alt\"\n    `,\n    gridRowGap: scales.spacing[2],\n  })\n\n  return (\n    <dl {...css()}>\n      {infoRows.map((rowProps) => (\n        <Datum key={rowProps.name} {...rowProps} {...props} />\n      ))}\n    </dl>\n  )\n}\n","import React from \"react\"\nimport { useStyle, scales, media } from \"styles\"\nimport { capitalize } from \"lodash-es\"\n\nimport { fonts } from \"styles\"\n\nimport { PolyhedronCtx } from \"components/ViewerPage/context\"\nimport DataDownloader from \"../DataDownloader\"\nimport { flexColumn } from \"styles/common\"\n\nimport { RenderProps } from \"./renderFuncs\"\nimport DataList from \"./DataList\"\n\nfunction Heading({ info }: RenderProps) {\n  const css = useStyle({\n    fontSize: scales.font[3],\n    marginBottom: scales.spacing[1],\n    lineHeight: 1.25,\n  })\n  return (\n    <h2 {...css()}>\n      {capitalize(info.canonicalName())} | {info.conwaySymbol()}\n    </h2>\n  )\n}\n\nexport default function InfoPanel() {\n  const polyhedron = PolyhedronCtx.useState()\n\n  const css = useStyle({\n    ...flexColumn(),\n    borderSpacing: 8,\n    borderCollapse: \"separate\",\n    padding: scales.spacing[3],\n    fontFamily: fonts.times,\n\n    // On non-mobile, display the download links on the bottom\n    [media.notMobile]: { height: \"100%\" },\n  })\n\n  const typeCss = useStyle({\n    fontSize: scales.font[5],\n    color: \"DimGrey\",\n    marginBottom: scales.spacing[3],\n  })\n\n  const downloaderCss = useStyle({\n    [media.mobile]: { marginTop: scales.spacing[4] },\n    [media.notMobile]: { marginTop: \"auto\" },\n  })\n\n  const info = polyhedron.specs\n\n  return (\n    <div {...css()}>\n      <Heading polyhedron={polyhedron.geom} info={info} />\n      <p {...typeCss()}>{info.group()}</p>\n      <DataList polyhedron={polyhedron.geom} info={info} />\n      <div {...downloaderCss()}>\n        <DataDownloader\n          name={polyhedron.specs.name()}\n          solid={polyhedron.geom.rawSolidData()}\n        />\n      </div>\n    </div>\n  )\n}\n","import React, { memo, useCallback, ButtonHTMLAttributes } from \"react\"\nimport { useStyle, scales } from \"styles\"\nimport { get, pick } from \"lodash-es\"\n\nimport Config from \"components/ConfigCtx\"\nimport {\n  configInputs,\n  ConfigInput as InputType,\n} from \"components/configOptions\"\nimport { hover, flexRow, flexColumn } from \"styles/common\"\nimport { andaleMono } from \"styles/fonts\"\n\nfunction getInputValue<T>(input: InputType<T>, el: HTMLInputElement) {\n  switch (input.type) {\n    case \"checkbox\":\n      return el.checked\n    default:\n      return el.value\n  }\n}\n\nfunction getInputProps<T>(input: InputType<T>, value: T) {\n  switch (input.type) {\n    case \"checkbox\":\n      return { checked: value }\n    case \"range\":\n      return {\n        ...pick(input, [\"min\", \"max\", \"step\"]),\n        value,\n      }\n    default:\n      return { value }\n  }\n}\n\ninterface InputProps<T> {\n  input: InputType<T>\n  value: T\n  setValue(key: string, value: T): void\n}\n\nfunction ConfigInput({ input, value, setValue }: InputProps<any>) {\n  const inputProps = getInputProps(input, value)\n  const onChange = useCallback(\n    (e) => setValue(input.key, getInputValue(input, e.target)),\n    [input, setValue],\n  )\n  switch (input.type) {\n    case \"select\":\n      return (\n        <select onChange={onChange} {...inputProps}>\n          {input.options?.map((option) => (\n            <option key={option} value={option}>\n              {option}\n            </option>\n          ))}\n        </select>\n      )\n    default:\n      return <input type={input.type} onChange={onChange} {...inputProps} />\n  }\n}\n\nconst LabelledInput = memo(({ input, value, setValue }: InputProps<any>) => {\n  const css = useStyle({\n    ...flexRow(undefined, \"space-between\"),\n    width: \"100%\",\n    fontFamily: andaleMono,\n    \":not(:last-child)\": {\n      marginBottom: scales.spacing[3],\n    },\n  })\n  return (\n    <label {...css()}>\n      {input.display}\n      <ConfigInput input={input} value={value} setValue={setValue} />\n    </label>\n  )\n})\n\nfunction ResetButton({ onClick }: ButtonHTMLAttributes<Element>) {\n  const css = useStyle({\n    ...hover,\n\n    width: 120,\n    height: 30,\n    marginTop: scales.spacing[3],\n\n    border: \"1px LightGray solid\",\n\n    fontFamily: andaleMono,\n    fontSize: scales.font[6],\n  })\n  return (\n    <button {...css()} type=\"button\" onClick={onClick}>\n      Reset\n    </button>\n  )\n}\n\nexport default function ConfigForm() {\n  const config = Config.useState()\n  const { setValue, reset } = Config.useActions()\n\n  const css = useStyle({\n    ...flexColumn(\"flex-end\"),\n    width: \"100%\",\n    padding: scales.spacing[3],\n  })\n  return (\n    <form {...css()}>\n      {configInputs.map((input) => (\n        <LabelledInput\n          key={input.key}\n          input={input}\n          value={get(config, input.key)}\n          setValue={setValue}\n        />\n      ))}\n      <ResetButton onClick={reset} />\n    </form>\n  )\n}\n","import { getPolyhedraNames } from \"./common\"\n\nconst uniformData = [\n  { name: \"platonic\", display: \"Platonic Solids\" },\n  { name: \"archimedean\", display: \"Archimedean Solids\" },\n  { name: \"prisms\", display: \"Prisms\" },\n  { name: \"antiprisms\", display: \"Antiprisms\" },\n]\n\nconst johnsonSubgroups = [\n  { name: \"pyramids\", index: 0 },\n  { name: \"cupolæ and rotunda\", index: 2 },\n  { name: \"elongated pyramids\", index: 6 },\n  { name: \"gyroelongated pyramids\", index: 9 },\n  { name: \"bipyramids\", index: 11 },\n  { name: \"elongated cupolæ / rotundæ\", index: 17 },\n  { name: \"gyroelongated cupolæ / rotundæ\", index: 21 },\n  { name: \"bicupolæ / rotundæ\", index: 25 },\n  { name: \"elongated bicupolæ / rotundæ\", index: 34 },\n  {\n    name: \"gyroelongated bicupolæ / rotundæ\",\n    index: 43,\n  },\n  { name: \"augmented prisms\", index: 48 },\n  { name: \"augmented dodecahedra\", index: 57 },\n  { name: \"diminished icosahedra\", index: 61 },\n  {\n    name: \"augmented Archimedean solids\",\n    index: 64,\n  },\n  { name: \"gyrate rhombicosidodecahedra\", index: 71 },\n  { name: \"diminished rhombicosidodecahedra\", index: 75 },\n  { name: \"snub antiprisms\", index: 83 },\n  { name: \"others\", index: 85 },\n]\n\nexport interface PolyhedronSubgroup {\n  name: string\n  polyhedra: string[]\n}\n\nexport interface PolyhedronGroup {\n  name: string\n  groups: PolyhedronSubgroup[]\n}\n\nfunction getUniformPolyhedra(): PolyhedronSubgroup[] {\n  return uniformData.map(({ name, display }) => ({\n    name: display,\n    polyhedra: getPolyhedraNames(name),\n  }))\n}\n\nfunction getEndIndex(i: number) {\n  return i === johnsonSubgroups.length - 1 ? 92 : johnsonSubgroups[i + 1].index\n}\n\nfunction getJohnsonPolyhedra(): PolyhedronSubgroup[] {\n  return johnsonSubgroups.map(({ name, index }, i) => ({\n    name,\n    polyhedra: getPolyhedraNames(\"johnson\").slice(index, getEndIndex(i)),\n  }))\n}\n\nexport const groups: PolyhedronGroup[] = [\n  { name: \"Uniform Polyhedra\", groups: getUniformPolyhedra() },\n  { name: \"Johnson Solids\", groups: getJohnsonPolyhedra() },\n]\n","import React, { memo, useState, InputHTMLAttributes } from \"react\"\nimport Icon from \"@mdi/react\"\nimport { mdiMagnify } from \"@mdi/js\"\n\nimport { useStyle, scales } from \"styles\"\nimport { andaleMono } from \"styles/fonts\"\nimport { flexRow } from \"styles/common\"\n\nconst duration = \"0.35s\"\n\nfunction SearchIcon({ focused }: { focused: boolean }) {\n  const css = useStyle(\n    {\n      transition: `fill ${duration}`,\n      position: \"absolute\",\n      // TODO This is kinda jank but I'm too lazy to fix it for a not useful feature\n      paddingLeft: 8,\n      paddingTop: 2,\n      fill: focused ? \"Gray\" : \"LightGray\",\n    },\n    [focused],\n  )\n  return (\n    <span {...css()}>\n      <Icon path={mdiMagnify} size={scales.size[1]} />\n    </span>\n  )\n}\n\nfunction SearchInput(props: InputHTMLAttributes<HTMLInputElement>) {\n  const css = useStyle({\n    transition: `border-color ${duration}`,\n    width: \"100%\",\n    height: scales.size[2],\n    paddingLeft: scales.spacing[4],\n\n    border: \"2px LightGray solid\",\n    borderRadius: 9999,\n\n    fontSize: scales.font[6],\n    fontFamily: andaleMono,\n\n    \":focus\": {\n      outline: \"none\",\n      borderColor: \"Gray\",\n      fill: \"Gray\",\n    },\n  })\n  return (\n    <input\n      {...props}\n      {...css()}\n      type=\"text\"\n      placeholder=\"Search...\"\n      aria-label=\"search\"\n    />\n  )\n}\n\ninterface Props {\n  value: string\n  onChange(value: string): void\n}\nexport default memo(function SearchBar({ value, onChange }: Props) {\n  const [isFocused, setFocus] = useState(false)\n\n  const css = useStyle({\n    ...flexRow(\"center\"),\n    padding: scales.spacing[2],\n    width: \"100%\",\n    position: \"relative\",\n  })\n  return (\n    <label {...css()}>\n      <SearchInput\n        value={value}\n        onChange={(e) => onChange(e.target.value)}\n        onFocus={() => setFocus(true)}\n        onBlur={() => setFocus(false)}\n      />\n      <SearchIcon focused={isFocused} />\n    </label>\n  )\n})\n","import { capitalize } from \"lodash-es\"\n\nimport React, { useState } from \"react\"\nimport { NavLink } from \"react-router-dom\"\nimport { fonts, useStyle, scales } from \"styles\"\n\nimport { PolyhedronGroup, PolyhedronSubgroup, groups } from \"data/list\"\nimport { escape } from \"utils\"\nimport { hover, padding, paddingVert, margin, marginVert } from \"styles/common\"\n\nimport SearchBar from \"./SearchBar\"\n\nfunction getFilteredPolyhedra(polyhedra: string[], filter: string) {\n  return polyhedra.filter((solid) => solid.includes(filter.toLowerCase()))\n}\n\nfunction filterSubgroups(subgroups: PolyhedronSubgroup[], filterText: string) {\n  return subgroups\n    .map(({ name, polyhedra }) => ({\n      name,\n      polyhedra: getFilteredPolyhedra(polyhedra, filterText),\n    }))\n    .filter(({ polyhedra }) => polyhedra.length > 0)\n}\n\nfunction filterGroups(groups: PolyhedronGroup[], filterText: string) {\n  return groups\n    .map(({ name, groups }) => ({\n      name,\n      groups: filterSubgroups(groups, filterText),\n    }))\n    .filter(({ groups }) => groups.length > 0)\n}\n\nfunction PolyhedronLink({ name }: { name: string }) {\n  const css = useStyle({\n    ...hover,\n    ...padding(scales.spacing[1], scales.spacing[3]),\n    textDecoration: \"none\",\n    display: \"block\",\n\n    color: \"DimGrey\",\n    lineHeight: 1.25,\n    fontFamily: fonts.andaleMono,\n    fontSize: scales.font[6],\n    overflow: \"hidden\",\n    textOverflow: \"ellipsis\",\n    whiteSpace: \"nowrap\",\n  })\n\n  const activeCss = useStyle({\n    color: \"DarkSlateGray\",\n    fontWeight: \"bolder\",\n  })\n\n  return (\n    <NavLink\n      to={`../../${escape(name)}/list`}\n      {...css()}\n      {...activeCss(\"activeClassName\")}\n    >\n      {capitalize(name)}\n    </NavLink>\n  )\n}\n\nfunction SubList({ polyhedra }: { polyhedra: string[] }) {\n  return (\n    <ul>\n      {polyhedra.map((name) => (\n        <li key={name}>\n          <PolyhedronLink name={name} />\n        </li>\n      ))}\n    </ul>\n  )\n}\n\nfunction SubgroupHeader({ name }: { name: string }) {\n  const css = useStyle({\n    ...margin(scales.spacing[1], scales.spacing[3]),\n    fontFamily: fonts.times,\n    fontSize: scales.font[5],\n  })\n  return <h3 {...css()}>{capitalize(name)}</h3>\n}\n\nfunction Subgroup({ name, polyhedra }: PolyhedronSubgroup) {\n  const css = useStyle(marginVert(scales.spacing[3]))\n\n  return (\n    <div {...css()}>\n      <SubgroupHeader name={name} />\n      <SubList polyhedra={polyhedra} />\n    </div>\n  )\n}\n\nfunction GroupHeader({ text }: { text: string }) {\n  const css = useStyle({\n    ...margin(scales.spacing[1], scales.spacing[3]),\n    fontFamily: fonts.times,\n    fontSize: scales.font[4],\n  })\n  return <h2 {...css()}>{text}</h2>\n}\n\nfunction Group({ group }: { group: PolyhedronGroup }) {\n  const { name, groups } = group\n  const css = useStyle({ marginTop: scales.spacing[2] })\n\n  return (\n    <div {...css()}>\n      <GroupHeader text={name} />\n      {groups.map((group) => (\n        <Subgroup key={group.name} {...group} />\n      ))}\n    </div>\n  )\n}\n\nexport default function ListPanel() {\n  const [filterText, setFilterText] = useState(\"\")\n  const filteredGroups =\n    filterText === \"\" ? groups : filterGroups(groups, filterText)\n\n  const css = useStyle(paddingVert(scales.spacing[2]))\n\n  return (\n    <section {...css()}>\n      <SearchBar value={filterText} onChange={setFilterText} />\n      {filteredGroups.map((group) => (\n        <Group key={group.name} group={group} />\n      ))}\n    </section>\n  )\n}\n","import React, { ComponentType } from \"react\"\nimport InfoPanel from \"./InfoPanel\"\nimport ConfigForm from \"./ConfigForm\"\nimport ListPanel from \"./ListPanel\"\n\ninterface Props {\n  panel: string\n  operationsPanel: ComponentType\n}\nexport default function Panels({\n  panel,\n  operationsPanel: OperationsPanel,\n}: Props) {\n  switch (panel) {\n    case \"info\":\n      return <InfoPanel />\n    case \"operations\":\n      return <OperationsPanel />\n    case \"options\":\n      return <ConfigForm />\n    case \"list\":\n      return <ListPanel />\n    case \"full\":\n      return null\n    default:\n      throw new Error(\"unknown tab\")\n  }\n}\n","import { capitalize } from \"lodash-es\"\nimport React from \"react\"\nimport { useStyle, scales } from \"styles\"\n\nimport { media, fonts } from \"styles\"\n\nfunction Title({ name }: { name: string }) {\n  const css = useStyle({\n    fontFamily: fonts.andaleMono,\n    fontSize: scales.font[2],\n\n    [media.notMobile]: {\n      fontWeight: \"bold\",\n      textAlign: \"left\",\n    },\n\n    [media.tabletPortrait]: {\n      // Otherwise, it bleeds into the sidebar\n      fontSize: scales.font[3],\n    },\n\n    // TODO consider making this style-less and defining the styles\n    // in mobile/desktop viewers\n    [media.mobile]: {\n      fontSize: scales.font[5],\n      lineHeight: 1.25,\n      textAlign: \"center\",\n    },\n  })\n  return (\n    <h1 data-testid=\"viewer-title\" {...css()}>\n      {capitalize(name)}\n    </h1>\n  )\n}\n\nexport default Title\n","import * as React from \"react\"\nimport JSZip from \"jszip\"\nimport FileSaver from \"file-saver\"\n\nimport { escape } from \"utils\"\nimport { allSolidNames } from \"data/common\"\n\n/**\n * Utility class to download image thumbnails. Do NOT use in production\n */\n// TODO rebuild this class with hoooks~~\nexport default class ImageDownloader extends React.Component<any> {\n  downloadImages = async () => {\n    const zip = new JSZip()\n    const canvas = document.getElementsByTagName(\"canvas\")\n    const ratio = canvas[0].width / canvas[0].height\n    const height = 150\n    canvas[0].height = height\n    canvas[0].width = ratio * height\n\n    const images = zip.folder(\"images\")\n\n    for (const solid of allSolidNames) {\n      await this.addImage(canvas, images, solid)\n    }\n    zip.generateAsync({ type: \"blob\" }).then((content) => {\n      FileSaver.saveAs(content, \"images.zip\")\n    })\n  }\n\n  addImage = async (canvas: any, folder: any, solid: any) => {\n    const { setPolyhedron } = this.props\n    return await new Promise((resolve) => {\n      setPolyhedron(solid, () => {\n        setTimeout(() => {\n          canvas[0].toBlob((v: any) => {\n            folder.file(`${escape(solid)}.png`, v, { base64: true })\n            resolve()\n          })\n        }, 100)\n      })\n    })\n  }\n\n  render() {\n    return <button onClick={this.downloadImages}>download images</button>\n  }\n}\n","import React from \"react\"\nimport { useStyle, scales } from \"styles\"\n\nimport { media, fonts } from \"styles\"\nimport { OperationCtx } from \"components/ViewerPage/context\"\n\nfunction getMessage(opName: string) {\n  switch (opName) {\n    case \"augment\":\n      return \"Select a face\"\n    case \"diminish\":\n    case \"gyrate\":\n      return \"Select a component\"\n    case \"sharpen\":\n    case \"contract\":\n      return \"Select a type of face\"\n    default:\n      return null\n  }\n}\n\nexport default function Prompt() {\n  const css = useStyle({\n    fontSize: scales.font[3],\n    fontFamily: fonts.andaleMono,\n    textAlign: \"center\",\n\n    [media.mobile]: {\n      fontSize: scales.font[4],\n    },\n  })\n  const { operation } = OperationCtx.useState()\n  if (!operation) return null\n  const message = getMessage(operation.name)\n\n  return message && <div {...css()}>{message}</div>\n}\n","import React, { useRef, useCallback } from \"react\"\nimport { SrOnly } from \"components/common\"\n\n/**\n * Provides a hidden heading and a function to focus on it.\n */\nexport default function useHiddenHeading(\n  value: string,\n): [JSX.Element, () => void] {\n  const ref = useRef<HTMLHeadingElement>(null)\n  const focusFn = useCallback(() => {\n    if (ref.current) ref.current.focus()\n  }, [])\n  const node = (\n    <SrOnly>\n      <h2 tabIndex={0} ref={ref}>\n        {value}\n      </h2>\n    </SrOnly>\n  )\n  return [node, focusFn]\n}\n","import React from \"react\"\nimport { useStyle, scales } from \"styles\"\n\nimport { ResizeButtons, OpGrid } from \"../common\"\nimport { flexColumn } from \"styles/common\"\n\nexport default function OperationsPanel() {\n  const css = useStyle({\n    ...flexColumn(),\n    padding: scales.spacing[3],\n    height: \"100%\",\n  })\n\n  const buttonCss = useStyle({ marginTop: \"auto\" })\n\n  return (\n    <section {...css()}>\n      <OpGrid />\n      <div {...buttonCss()}>\n        <ResizeButtons />\n      </div>\n    </section>\n  )\n}\n","import React from \"react\"\nimport { useStyle, scales } from \"styles\"\n\nimport { NavMenu, Panels, useHiddenHeading } from \"../common\"\nimport { paddingHoriz, scroll } from \"styles/common\"\n\nimport OperationsPanel from \"./OperationsPanel\"\n\ninterface Props {\n  panel: string\n  solid: string\n  compact?: boolean\n}\n\nconst menuH = scales.size[3]\n\nexport default function Sidebar({ panel, solid, compact }: Props) {\n  const [header, focusOnHeader] = useHiddenHeading(panel)\n\n  const css = useStyle(\n    {\n      width: \"100%\",\n      height: \"100%\",\n      position: \"relative\",\n      display: \"grid\",\n      gridTemplateRows: `${menuH} 1fr`,\n      gridTemplateAreas: '\"menu\" \"content\"',\n      borderLeft: compact ? undefined : \"1px solid LightGray\",\n    },\n    [compact],\n  )\n\n  const navCss = useStyle(\n    {\n      ...paddingHoriz(scales.spacing[2]),\n      gridArea: \"menu\",\n      height: menuH,\n      borderBottom: compact ? undefined : \"1px solid LightGray\",\n    },\n    [compact],\n  )\n\n  const contentCss = useStyle({\n    ...scroll(\"y\"),\n    gridArea: \"content\",\n    position: \"relative\",\n  })\n  return (\n    <section {...css()}>\n      <div {...navCss()}>\n        <NavMenu compact={compact} onClick={focusOnHeader} />\n      </div>\n      {!compact && (\n        <div {...contentCss()}>\n          {header}\n          <Panels panel={panel} operationsPanel={OperationsPanel} />\n        </div>\n      )}\n    </section>\n  )\n}\n","//@flow\n\nimport React from \"react\"\nimport { useStyle, scales } from \"styles\"\n\nimport { absolute, absoluteFull, paddingHoriz } from \"styles/common\"\nimport { BackLink, Title, Options, Prompt } from \"../common\"\n\ninterface Props {\n  solid: string\n}\n\n// TODO replace all the padding/absolute values with Grid\nexport default function Overlay({ solid }: Props) {\n  const css = useStyle({\n    ...absoluteFull,\n    pointerEvents: \"none\",\n  })\n\n  const title = useStyle({\n    ...absolute(\"bottom\", \"left\"),\n    pointerEvents: \"initial\",\n    padding: scales.spacing[4],\n  })\n\n  const homeLink = useStyle({\n    ...absolute(\"top\", \"left\"),\n    pointerEvents: \"initial\",\n    paddingLeft: scales.spacing[2],\n  })\n\n  const options = useStyle({\n    ...paddingHoriz(scales.spacing[4]),\n    height: \"100%\",\n  })\n\n  const prompt = useStyle({\n    paddingTop: scales.spacing[3],\n    position: \"absolute\",\n    top: 0,\n    right: 0,\n    left: 0,\n  })\n\n  return (\n    <div {...css()}>\n      <div {...homeLink()}>\n        <BackLink solid={solid} />\n      </div>\n      <div {...title()}>\n        <Title name={solid} />\n      </div>\n      <div {...prompt()}>\n        <Prompt />\n      </div>\n      <div {...options()}>\n        <Options />\n      </div>\n    </div>\n  )\n}\n","import React, { memo } from \"react\"\n\nimport { useStyle } from \"styles\"\nimport { flexRow } from \"styles/common\"\nimport Sidebar from \"./Sidebar\"\nimport Overlay from \"./Overlay\"\nimport { SolidScene } from \"../common\"\n\ninterface Props {\n  panel: string\n  solid: string\n}\n\nconst sidebarW = \"24rem\"\n\nfunction Scene({ solid, full }: Pick<Props, \"solid\"> & { full: boolean }) {\n  const css = useStyle(\n    {\n      position: \"relative\",\n      width: full ? \"100%\" : `calc(100% - ${sidebarW})`,\n      height: \"100%\",\n      alignSelf: \"flex-start\",\n    },\n    [full],\n  )\n  return (\n    <div {...css()}>\n      <SolidScene />\n      <Overlay solid={solid} />\n    </div>\n  )\n}\n\nfunction StyledSidebar({\n  solid,\n  panel,\n  compact,\n}: Props & { compact: boolean }) {\n  const css = useStyle(\n    compact\n      ? {\n          position: \"absolute\",\n          top: 0,\n          right: 0,\n        }\n      : {\n          position: \"relative\",\n          height: \"100%\",\n          minWidth: sidebarW,\n          maxWidth: sidebarW,\n        },\n    [compact],\n  )\n  return (\n    <div {...css()}>\n      <Sidebar panel={panel} solid={solid} compact={compact} />\n    </div>\n  )\n}\n\nexport default memo(function DesktopViewer({ solid, panel }: Props) {\n  const full = panel === \"full\"\n\n  const css = useStyle({\n    ...flexRow(),\n    position: \"fixed\",\n    width: \"100vw\",\n    height: \"100vh\",\n    overflow: \"hidden\",\n  })\n  return (\n    <div {...css()}>\n      <Scene solid={solid} full={full} />\n      <StyledSidebar solid={solid} panel={panel} compact={full} />\n    </div>\n  )\n})\n","import React from \"react\"\nimport { useStyle, scales } from \"styles\"\n\nimport { OpGrid, Prompt, Options, ResizeButtons } from \"../common\"\nimport { flexColumn } from \"styles/common\"\n\nexport default function OperationsPanel() {\n  const css = useStyle({\n    ...flexColumn(),\n    height: \"100%\",\n    pointerEvents: \"none\",\n    padding: scales.spacing[2],\n  })\n\n  const resizeButtons = useStyle({\n    pointerEvents: \"initial\",\n  })\n\n  const prompt = useStyle({\n    marginTop: scales.spacing[2],\n    marginBottom: \"auto\",\n  })\n\n  const options = useStyle({\n    marginTop: \"auto\",\n    marginBottom: scales.spacing[2],\n  })\n\n  const opGrid = useStyle({\n    width: \"100%\",\n    pointerEvents: \"initial\",\n  })\n\n  // TODO I really wanna create a wrapper component for this...\n  return (\n    <section {...css()}>\n      <div {...resizeButtons()}>\n        <ResizeButtons />\n      </div>\n      <div {...prompt()}>\n        <Prompt />\n      </div>\n      <div {...options()}>\n        <Options />\n      </div>\n      <div {...opGrid()}>\n        <OpGrid />\n      </div>\n    </section>\n  )\n}\n","import React, { memo } from \"react\"\nimport { CSSProperties } from \"aphrodite\"\n\nimport { useStyle, media, scales } from \"styles\"\nimport { scroll, paddingHoriz, flexRow } from \"styles/common\"\nimport {\n  BackLink,\n  Title,\n  NavMenu,\n  SolidScene,\n  Panels,\n  useHiddenHeading,\n} from \"../common\"\n\nimport OperationsPanel from \"./OperationsPanel\"\n\nconst titleHeight = \"3rem\"\n\nfunction mobile(styles: (navH: string) => CSSProperties) {\n  return {\n    [media.mobileLandscape]: styles(\"3rem\"),\n    [media.mobilePortrait]: styles(scales.size[3]),\n  }\n}\n\ninterface Props {\n  panel: string\n  solid: string\n}\n\nfunction Header({ solid }: Pick<Props, \"solid\">) {\n  const css = useStyle({\n    height: titleHeight,\n    ...paddingHoriz(scales.spacing[2]),\n    borderBottom: \"1px solid LightGray\",\n    width: \"100%\",\n    display: \"grid\",\n    gridTemplateColumns: `${scales.size[2]} 1fr ${scales.size[2]}`,\n    alignItems: \"center\",\n    justifyItems: \"center\",\n  })\n  return (\n    <header {...css()}>\n      <BackLink solid={solid} />\n      <Title name={solid} />\n    </header>\n  )\n}\n\nfunction Content({\n  panel,\n  header,\n}: Pick<Props, \"panel\"> & { header: JSX.Element }) {\n  const transparent = [\"operations\", \"full\"].includes(panel)\n  const css = useStyle(\n    {\n      ...scroll(\"y\"),\n      gridArea: \"content\",\n      position: \"relative\",\n      zIndex: 100,\n      ...(transparent\n        ? { pointerEvents: \"none\" }\n        : { backgroundColor: \"rgba(255, 255, 255, 0.75)\" }),\n    },\n    [transparent],\n  )\n  return (\n    <div {...css()}>\n      {header}\n      <Panels panel={panel} operationsPanel={OperationsPanel} />\n    </div>\n  )\n}\n\nexport default memo(function MobileViewer({ panel, solid }: Props) {\n  const [header, focusOnHeader] = useHiddenHeading(panel)\n\n  const css = useStyle({\n    position: \"relative\",\n    width: \"100vw\",\n    height: \"100vh\",\n    display: \"grid\",\n    gridTemplateAreas: '\"title\" \"content\" \"nav\"',\n    ...mobile((navH) => ({\n      gridTemplateRows: `${titleHeight} 1fr ${navH}`,\n    })),\n  })\n\n  const sceneCss = useStyle({\n    ...mobile((navH) => ({\n      height: `calc(100vh - ${navH} - ${titleHeight})`,\n    })),\n    zIndex: 0,\n    gridArea: \"content\",\n    position: \"relative\",\n  })\n\n  const navCss = useStyle({\n    ...mobile((navH) => ({\n      height: navH,\n    })),\n    ...flexRow(\"center\"),\n    gridArea: \"nav\",\n    borderTop: \"1px solid LightGray\",\n  })\n\n  return (\n    <section {...css()}>\n      <Header solid={solid} />\n      <Content panel={panel} header={header} />\n      <main {...sceneCss()}>\n        <SolidScene />\n      </main>\n      <div {...navCss()}>\n        <NavMenu onClick={focusOnHeader} />\n      </div>\n    </section>\n  )\n})\n","import { capitalize } from \"lodash-es\"\nimport React, { useEffect } from \"react\"\nimport { useParams, useNavigate } from \"react-router-dom\"\n\nimport { escape } from \"utils\"\nimport { wrapProviders } from \"components/common\"\nimport { OperationCtx, TransitionCtx, PolyhedronCtx } from \"./context\"\nimport DesktopViewer from \"./DesktopViewer\"\nimport MobileViewer from \"./MobileViewer\"\nimport { usePageTitle } from \"components/common\"\nimport useMediaInfo from \"components/useMediaInfo\"\n\ninterface InnerProps {\n  solid: string\n  panel: string\n}\n\nfunction InnerViewer({ solid, panel }: InnerProps) {\n  const { unsetOperation } = OperationCtx.useActions()\n  const { setPolyhedronToName } = PolyhedronCtx.useActions()\n  const polyhedron = PolyhedronCtx.useState()\n  const navigate = useNavigate()\n  // Use a buffer variable to keep the two states in sync\n  const [solidSync, setSolidSync] = React.useState(solid)\n\n  // When either `solid` (derived from the route) or `polyhedron.name` (derived from operation)\n  // chagnes, update the *other* state.\n  useEffect(() => {\n    setSolidSync(solid)\n  }, [solid])\n\n  useEffect(() => {\n    setSolidSync(polyhedron.specs.name())\n  }, [polyhedron.specs])\n\n  useEffect(() => {\n    if (polyhedron.specs.name() !== solidSync) {\n      // If the route has changed (and it wasn't from an operation)\n      // cancel the current operation and set the polyhedorn model\n      unsetOperation()\n      setPolyhedronToName(solidSync)\n    } else if (solid !== solidSync) {\n      // If an operation was executed, update the URL\n      navigate(`/${escape(polyhedron.specs.name())}/operations`)\n    }\n    // Don't depend on `solid` or `polyhedron.name` over here:\n    // this is how the two states get synced with each other\n    // Also don't depend on `navigate` because it's not memoized\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [solidSync, setPolyhedronToName, unsetOperation])\n\n  const { device } = useMediaInfo()\n\n  const ViewerComponent = device === \"desktop\" ? DesktopViewer : MobileViewer\n\n  return <ViewerComponent solid={solid} panel={panel} />\n}\n\nconst Providers = wrapProviders([TransitionCtx.Provider, OperationCtx.Provider])\n\nexport default function Viewer({ solid }: { solid: string }) {\n  const { panel = \"operations\" } = useParams()\n  usePageTitle(`${capitalize(solid)} - Polyhedra Viewer`)\n\n  return (\n    <PolyhedronCtx.Provider name={solid}>\n      <Providers>\n        <InnerViewer solid={solid} panel={panel} />\n      </Providers>\n    </PolyhedronCtx.Provider>\n  )\n}\n","import React from \"react\"\nimport {\n  Routes,\n  Route,\n  Navigate,\n  useParams,\n  useLocation,\n} from \"react-router-dom\"\n\nimport { escape, choose } from \"utils\"\nimport { isValidSolid, allSolidNames } from \"data/common\"\nimport { isAlternateName } from \"data/alternates\"\nimport { isConwayNotation, fromConwayNotation } from \"./conway\"\n\nimport ErrorPage from \"components/ErrorPage\"\nimport Viewer from \"./Viewer\"\n\nconst unescapeName = (name: string) => name.replace(/-/g, \" \")\n\nfunction resolveSolidName(solid: string) {\n  if (solid === \"random\") {\n    return choose(allSolidNames)\n  }\n  if (isConwayNotation(solid)) {\n    return fromConwayNotation(solid)\n  }\n  if (isAlternateName(solid) || isValidSolid(solid)) {\n    return solid\n  }\n  return null\n}\n\nexport default function ViewerPage() {\n  const params = useParams()\n  const { pathname } = useLocation()\n  const solidParam = unescapeName(params.solid)\n  const solid = resolveSolidName(solidParam)\n\n  if (!solid) {\n    return <ErrorPage />\n  }\n\n  if (solid !== solidParam) {\n    return (\n      <Navigate replace to={pathname.replace(params.solid, escape(solid))} />\n    )\n  }\n\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Navigate replace to=\"operations\" />} />\n      <Route path=\":panel\" element={<Viewer solid={solid} />} />\n    </Routes>\n  )\n}\n"],"sourceRoot":""}